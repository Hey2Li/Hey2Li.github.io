<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter-Stream学习（二）</title>
    <link href="/2024/06/24/Flutter-Stream%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/06/24/Flutter-Stream%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在上一篇文章中我们大概了解关于Stream的一些概念和原理，并通过代码简洁说明了Stream的流程。本篇文章进一步学习Stream的其他内容同时用代码加深记忆。</p></blockquote><h2 id="Stream开发实战"><a href="#Stream开发实战" class="headerlink" title="Stream开发实战"></a>Stream开发实战</h2><p>通过上一篇文章对接口和分类的分析，已经对Stream有了进一步的认识，接下来通过例子来检验一下。</p><h3 id="利用Stream实现事件的广播"><a href="#利用Stream实现事件的广播" class="headerlink" title="利用Stream实现事件的广播"></a>利用Stream实现事件的广播</h3><p>事件的广播，在开发中总会遇到，尤其是在跨组件或跨页面的场景，相信大部分的开发在项目中都会引入EventBus的三方或者自研框架。例如：当我编辑资料后，保存完成通知其他页面进行刷新以展示最新的信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// user entity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> uid;<br>  <span class="hljs-built_in">String</span> name;<br><br>  UserInfo(<span class="hljs-keyword">this</span>.uid, <span class="hljs-keyword">this</span>.name);<br>&#125;<br><br><span class="hljs-comment">// userinfo update</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoChangeEvent</span> </span>&#123;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> _controller = StreamController&lt;UserInfo&gt;.broadcast();<br><br>  <span class="hljs-keyword">static</span> StreamSubscription&lt;UserInfo&gt; subscribe(<span class="hljs-built_in">Function</span>(UserInfo) callback) &#123;<br>    <span class="hljs-keyword">return</span> _controller.stream.listen(callback);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> broadcast(UserInfo userInfo) &#123;<br>    _controller.add(userInfo);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 用户编辑页面</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfileViewModel</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">// 点击 save 时，会调用到 broadcast 方法向外发送事件</span><br>  <span class="hljs-keyword">void</span> onSave(<span class="hljs-built_in">int</span> uid, <span class="hljs-built_in">String</span> name) &#123;<br>    UserInfoChangeEvent.broadcast(UserInfo(uid, name));<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 其它页面状态刷新</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">ViewWidget</span>&gt; </span>&#123;<br><br>  StreamSubscription&lt;UserInfo&gt;? _subscription;<br>  UserInfo? _curUserInfo;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 初始化时，监听 UserInfoChangeEvent</span><br>    _subscription = UserInfoChangeEvent.subscribe((userInfo) &#123;<br>      setState(() &#123;<br>        _curUserInfo = userInfo;<br>      &#125;)<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    <span class="hljs-comment">// 退出时，要取消监听。否则会有内存泄漏</span><br>    _subscription?.cancel();<br>    _subscription = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，<code>UserInfoChangeEvent</code>定义了广播类型的<code>StreamController</code>，并且向外暴露了<code>subscribe</code>和<code>broadcast</code>接口，用户编辑页面后点击保存时执行<code>onSave</code>方法，方法中的<code>UserInfoChangeEvent</code>调用<code>broadcast</code>方法向外部发送数据变化的事件；然后ViewState在初始化是注册了监听<code>UserInfoChangeEvent</code>的<code>subscription</code>，<code>subscription</code>接收到事件并获取更新后的<code>userInfo</code>赋值给<code>_curUserInfo</code>,同时刷新页面。</p><h3 id="StreamBuilder实现Widget自动刷新"><a href="#StreamBuilder实现Widget自动刷新" class="headerlink" title="StreamBuilder实现Widget自动刷新"></a>StreamBuilder实现Widget自动刷新</h3><p>Flutter提供了一个组件StreamBuilder，可以帮助我们方便的监听Stream并刷新Widget。例如进入一个页面时，通常会有一个数据加载的过程，此时页面会从Loading状态到Loaded/LoadError的状态变更，不同的状态呈现不同的页面，这时我们就需要定义一个LoadingState的枚举类型，在数据加载后通过StreamController发布LoadState状态，StreamBuilder监听到更新会自动触发Widget的刷新。</p><p>AsyncSnapShot是快照的意思，保存此刻最新的事件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> LoadingState &#123;<br>  loading,<br>  error,<br>  success,<br>&#125;<br>....<br>StreamBuilder&lt;LoadingState&gt;(<br>  stream: viewModel.loadingStateStrem,<br>  initialData: LoadingState.loading,<br>  builder: (context, snapshot) &#123;<br>   <span class="hljs-comment">//根据snapShot的数据返回处理</span><br>          <span class="hljs-keyword">var</span> data = snapshot.data;<br>          <span class="hljs-keyword">if</span> (data == LoadingState.loading) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: CircularProgressIndicator());<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data == LoadingState.error) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">&#x27;加载失败&#x27;</span>));<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data == LoadingState.success) &#123;<br>            <span class="hljs-keyword">return</span> TextWidget(text);<br>          &#125;<br>        &#125;,<br>      )<br></code></pre></td></tr></table></figure><p>不过StreamBuilder也有坑，对于Stream来说，事件被消费了就会丢掉，无论是StreamController还是Stream都不会保存上次的值，以页面加载为例页面进来后viewModel执行数据加载完成后，想loadingStateStream里发布了Loaded的状态，如果此时StreamBuilder还没有开始布局，那Builder就无法收到这次事件，等到界面已经布局完成时就会丢失此次的事件，snapshot拿到还是初始状态，也就是loading，这样就会导致页面显示异常。</p><p>对此可能会有疑问，为什么StreamBuilder不能一开始就添加到build里呢？当然可以，但是即便如此也无法保证StreamBuilder的监听比viewModel的状态更新要早，因为如果页面的内容较长，一开始StreamBuilder还不在可视区内，它的initState方法就不会执行，也就不会监听LoadingState.</p><p>StreamBuilder会面临这样的困境，归根结底是Stream设计导致的。</p><h3 id="Stream的变换和处理"><a href="#Stream的变换和处理" class="headerlink" title="Stream的变换和处理"></a>Stream的变换和处理</h3><p>前面在介绍Stream的接口时，我们提到Stream有很多操作方法。接下来着重挑几个名字不好理解的展开讲讲</p><h4 id="Future-lt-E-gt-drain-lt-E-gt-E-futureValue"><a href="#Future-lt-E-gt-drain-lt-E-gt-E-futureValue" class="headerlink" title="Future&lt;E&gt; drain&lt;E&gt;([E? futureValue])"></a><code>Future&lt;E&gt; drain&lt;E&gt;([E? futureValue])</code></h4><p><code>drain</code>意为‘‘排出，消耗’’。这里指‘‘排掉’’这条流里的所有事件，只响应结束信号，当流关闭时返回<code>futureValue</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> Stream.fromIterable([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).drain(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">print</span>(result); <span class="hljs-comment">// Outputs: 100.</span><br></code></pre></td></tr></table></figure><h4 id="Future-lt-S-gt-fold-lt-S-gt-S-initialValue-S-Function-S-previous-T-element-combine"><a href="#Future-lt-S-gt-fold-lt-S-gt-S-initialValue-S-Function-S-previous-T-element-combine" class="headerlink" title="Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S Function(S previous, T element) combine)"></a><code>Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S Function(S previous, T element) combine)</code></h4><p>事件迭代。根据combine合并流里面的事件，该方法可以返回指定类型的S，同时可以指定初始值initialValue。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> Stream&lt;<span class="hljs-built_in">int</span>&gt;.fromIterable([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>])<br>     .fold&lt;<span class="hljs-built_in">String</span>&gt;(<span class="hljs-string">&quot;0&quot;</span>, (previous, element) =&gt; <span class="hljs-string">&quot;<span class="hljs-subst">$previous</span> - <span class="hljs-subst">$element</span>&quot;</span>);<br><span class="hljs-built_in">print</span>(result); <span class="hljs-comment">// 0 - 2 - 4 - 6 - 8 - 10</span><br></code></pre></td></tr></table></figure><h4 id="Future-lt-T-gt-reduce-T-Function-T-previous-T-element-combine"><a href="#Future-lt-T-gt-reduce-T-Function-T-previous-T-element-combine" class="headerlink" title="Future&lt;T&gt; reduce(T Function(T previous, T element) combine)"></a><code>Future&lt;T&gt; reduce(T Function(T previous, T element) combine)</code></h4><p>也是事件迭代。与fold不同的是，reduce无法指定初始值且它只能返回与源流相同的类型T。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> Stream.fromIterable&lt;<span class="hljs-built_in">int</span>&gt;([<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>])<br>     .reduce&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">10</span>, (previous, element) =&gt; previous + element);<br><span class="hljs-built_in">print</span>(result); <span class="hljs-comment">// 38</span><br></code></pre></td></tr></table></figure><h4 id="Future-pipe-StreamConsumer-lt-T-gt-streamConsumer"><a href="#Future-pipe-StreamConsumer-lt-T-gt-streamConsumer" class="headerlink" title="Future pipe(StreamConsumer&lt;T&gt; streamConsumer)"></a><code>Future pipe(StreamConsumer&lt;T&gt; streamConsumer)</code></h4><p>流管道拼接。将当前流的事件流流向streamConsumer中，streamConsumer的子类实现通常是一个StreamController，拿到事件后通知给它的订阅者。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> controller = StreamController&lt;<span class="hljs-built_in">int</span>&gt;();  <br><span class="hljs-keyword">var</span> stream = controller.stream;<br><br>stream.listen((event) &#123;    <br>  <span class="hljs-built_in">print</span>(event); <span class="hljs-comment">// 2 4 6 8 10</span><br>&#125;);<br>  <br><span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> Stream&lt;<span class="hljs-built_in">int</span>&gt;.fromIterable([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]).pipe(controller);  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;result: <span class="hljs-subst">$result</span>&quot;</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><h4 id="Stream-lt-E-gt-asyncExpand-lt-E-gt-Stream-lt-E-gt-Function-T-event-convert"><a href="#Stream-lt-E-gt-asyncExpand-lt-E-gt-Stream-lt-E-gt-Function-T-event-convert" class="headerlink" title="Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt;? Function(T event) convert)"></a><code>Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt;? Function(T event) convert)</code></h4><p>异步展开。将原流中的事件做一次展操作，得到一个E类型的新流。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> stream = Stream&lt;<span class="hljs-built_in">int</span>&gt;.fromIterable([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]);<br>  <br><span class="hljs-keyword">var</span> newStream = stream.asyncExpand((event) &#123;<br>  <span class="hljs-keyword">return</span> Stream&lt;<span class="hljs-built_in">int</span>&gt;.fromIterable([event, event + <span class="hljs-number">1</span>]);<br>&#125;);<br>  <br>newStream.listen((event)&#123;<br>  <span class="hljs-built_in">print</span>(event);  <span class="hljs-comment">// 2 3 4 5 6 7 8 9 10</span><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="Stream-lt-E-gt-asyncMap-lt-E-gt-FutureOr-lt-E-gt-Function-T-event-convert"><a href="#Stream-lt-E-gt-asyncMap-lt-E-gt-FutureOr-lt-E-gt-Function-T-event-convert" class="headerlink" title="Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; Function(T event) convert)"></a><code>Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; Function(T event) convert)</code></h4><p>异步映射。跟asyncExpand类似，只是转换操作返回的是FutureOr对象，为那些转换过程中涉及到异步处理的场景提供便利。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> newStream = stream.asyncMap((event) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> event + <span class="hljs-number">1</span>;<br>&#125;);<br><br>newStream.listen((event)&#123;<br>  <span class="hljs-built_in">print</span>(event); <span class="hljs-comment">// 3 5 7 9 11</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>说了这么多，现在来检验一下。假设有一段逻辑，controller会增加三个事件，分别是<code>add(1) add(2) add(3)</code>，<code>subscription</code>会在每次收到事件时打印<code>output:$event</code>， 中间会有一次暂停，3秒后恢复，猜一下以下几种场景下最后输出的属性是什么？</p><h4 id="1-同步流"><a href="#1-同步流" class="headerlink" title="1.同步流"></a>1.同步流</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">// 同步流：sync 为 true</span><br>  <span class="hljs-keyword">var</span> controller = StreamController&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">sync</span>: <span class="hljs-keyword">true</span>);<br>  <span class="hljs-keyword">var</span> subscription = controller.stream.listen((event) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;output: <span class="hljs-subst">$event</span>&#x27;</span>);<br>  &#125;);<br>  <br>  controller.add(<span class="hljs-number">1</span>);<br>  controller.add(<span class="hljs-number">2</span>);<br>  controller.add(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;暂停&#x27;</span>);<br>  subscription.pause();<br><br>  Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>), () &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3秒后 -&gt; 恢复&#x27;</span>);<br>    subscription.resume();<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// will print:</span><br><span class="hljs-comment">// output: 1</span><br><span class="hljs-comment">// output: 2</span><br><span class="hljs-comment">// output: 3</span><br><span class="hljs-comment">// 暂停</span><br><span class="hljs-comment">// 3秒后 -&gt; 恢复</span><br></code></pre></td></tr></table></figure><h4 id="2-异步流"><a href="#2-异步流" class="headerlink" title="2.异步流"></a>2.异步流</h4><p>保持1中其他代码不变，将sync的值设置为false</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>() <span class="hljs-keyword">async</span></span> &#123;<br>  <span class="hljs-keyword">var</span> controller = StreamController&lt;<span class="hljs-built_in">int</span>&gt;(sync: <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">var</span> subscription = controller.stream.listen((<span class="hljs-keyword">event</span>) &#123;<br>    print(<span class="hljs-string">&#x27;output: $event&#x27;</span>);<br>  &#125;);<br>  <br>  controller.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>  controller.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br>  controller.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br><br>  print(<span class="hljs-string">&#x27;暂停&#x27;</span>);<br>  subscription.pause();<br><br>  Future.delayed(<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">Duration</span>(<span class="hljs-params">seconds: <span class="hljs-number">3</span></span>), ()</span> &#123;<br>    print(<span class="hljs-string">&#x27;3秒后 -&gt; 恢复&#x27;</span>);<br>    subscription.resume();<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// will print:</span><br><span class="hljs-comment">// 暂停</span><br><span class="hljs-comment">// 3秒后 -&gt; 恢复</span><br><span class="hljs-comment">// output: 1</span><br><span class="hljs-comment">// output: 2</span><br><span class="hljs-comment">// output: 3</span><br></code></pre></td></tr></table></figure><h4 id="3-异步流：使用Future-delayed延迟暂停"><a href="#3-异步流：使用Future-delayed延迟暂停" class="headerlink" title="3.异步流：使用Future.delayed延迟暂停"></a>3.异步流：使用Future.delayed延迟暂停</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future.delayed(<span class="hljs-built_in">Duration</span>.zero, ()&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;暂停&#x27;</span>);<br>    subscription.pause();<br><br>    Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>), () &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3秒后 -&gt; 恢复&#x27;</span>);<br>      subscription.resume();<br>    &#125;);<br>  &#125;);<br><br><span class="hljs-comment">// will print</span><br><span class="hljs-comment">// output: 1</span><br><span class="hljs-comment">// output: 2</span><br><span class="hljs-comment">// output: 3</span><br><span class="hljs-comment">// 暂停</span><br><span class="hljs-comment">// 3秒后 -&gt; 恢复</span><br></code></pre></td></tr></table></figure><h4 id="4-异步流：使用-scheduleMicrotask-延迟暂停"><a href="#4-异步流：使用-scheduleMicrotask-延迟暂停" class="headerlink" title="4. 异步流：使用 scheduleMicrotask 延迟暂停"></a>4. 异步流：使用 scheduleMicrotask 延迟暂停</h4><p>保持 3 中其它代码不变，用<code>scheduleMicrotask</code>代替<code>Future.delayed</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">  scheduleMicrotask(() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;暂停&#x27;</span>);<br>    subscription.pause();<br>    Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>), () &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3秒后 -&gt; 恢复&#x27;</span>);<br>      subscription.resume();<br>    &#125;);<br>  &#125;);<br><br><span class="hljs-comment">// will print</span><br><span class="hljs-comment">// output: 1</span><br><span class="hljs-comment">// 暂停</span><br><span class="hljs-comment">// 3秒后 -&gt; 恢复</span><br><span class="hljs-comment">// output: 2</span><br><span class="hljs-comment">// output: 3</span><br></code></pre></td></tr></table></figure><p>上面的输出是否如你所料？相信如果你理解了之前的介绍，对1 2 3点的输出结果是没有问题的。但是对于第 4 点：虽然同样为延迟暂停，3 和 4 中的输出完全不一样，4 中的输出在输出<code>output: 1</code>后才会触发暂停。这又是为什么呢？要解释这个输出，就要从源码出发了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所以，我们首先要从概念上理解他们，其次我们还要从代码上知道具体的实现。当程度的执行不及预期，缺乏代码实现层面的理解，我们便会显得手忙脚乱。像前面出现的<strong>StreamBuilder处理中的坑</strong>和<strong>输出顺序的问题</strong>，只有阅读底层源码，才能发现原因并准确修复。下一篇文章，将从源码实现上深入分析<code>Stream</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Stream</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter-Stream学习（一）</title>
    <link href="/2024/06/21/Flutter-Stream%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/21/Flutter-Stream%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言：在Dart库中，实现异步编程主要有两种方式Future&amp;Stream，使用他们需要引入<code>dart:async</code>。</p><p>本文主要介绍Stream的相关概念及基础用法和原理解析。</p></blockquote><h2 id="Stream的基本用法"><a href="#Stream的基本用法" class="headerlink" title="Stream的基本用法"></a>Stream的基本用法</h2><p><code>Stream</code>能通过<code>async*</code>和<code>StreamController</code>产生，也能通过其他<code>Stream</code>转换而来，相较于<code>async*</code>，<code>StreamController</code>因为灵活性高，因此更为常用，但两者在使用场景也有一定差异。</p><h3 id="Async"><a href="#Async" class="headerlink" title="Async*"></a>Async*</h3><p><code>async</code>在flutter开发中很常见，但是加上*的<code>async*</code>可能就未必见过，同样作为Flutter里异步处理的一环，<code>async</code>主要是跟<code>Future</code>打交道，而<code>async*</code>处理的对象是<code>Stream</code>，<code>async*</code>在使用上需要搭配<code>yield</code>。下面的代码演示了如何使用<code>async*</code>进行1到10的相加。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart">Stream&lt;<span class="hljs-built_in">int</span>&gt;countStream(<span class="hljs-built_in">int</span> to) <span class="hljs-keyword">async</span>*&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Stream 被监听&#x27;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= to; i++) &#123;<br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>&#125;<br>Future&lt;<span class="hljs-built_in">int</span>&gt;sumStream(Stream&lt;<span class="hljs-built_in">int</span>&gt; stream) <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">final</span> value <span class="hljs-keyword">in</span> stream) &#123;<br>    sum += value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>() &#123;<br>  <span class="hljs-keyword">var</span> stream = countStream(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">// 当注释掉下面这行，控制台不会打印出 &quot;stream 被监听&quot;，也就表示 async* 方法体没被执行</span><br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">await</span> sumStream(stream);<br>  <span class="hljs-built_in">print</span>(sum); <span class="hljs-comment">// 55</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>async*</code>方法体里<code>yield</code>在每次的遍历中，都往<code>Stream</code>返回一个数据，通过<code>await for</code> 的监听拿到每次返回的值，接着执行<code>sum</code>操作。值得注意的是，<code>async*</code>这种方式产生的Stream，当<code>stream</code>没有被监听时，<code>async*</code> 方法体是不会被执行的。</p><p>如果你看着<code>async*</code>还有点别扭，请记住：**<code>async</code>返回的是一个<code>Future</code>，而<code>async*</code>返回的是一个<code>Stream</code>。</p><h3 id="StreamController"><a href="#StreamController" class="headerlink" title="StreamController"></a>StreamController</h3><p>在flutter中<code>StreamController</code>是比较常用的创建<code>Stream</code>方法。只需要构造出<code>StreamController</code>对象，然后通过<code>.stream</code>就可以得到对应的<code>Stream</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>Stream&lt;<span class="hljs-built_in">int</span>&gt; countStream(<span class="hljs-built_in">int</span> to) &#123;<br>  <span class="hljs-comment">//先创建StreamController</span><br>  <span class="hljs-keyword">late</span> StreamController&lt;<span class="hljs-built_in">int</span>&gt; controller;<br>  controller = StreamController&lt;<span class="hljs-built_in">int</span>&gt;(onListen: () &#123;<br>    <span class="hljs-comment">//当Stream被监听时会触发onListen回调</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= to; i++) &#123;<br>      controller.add(i);<br>    &#125;<br>    controller.close();<br>  &#125;);<br>  <span class="hljs-keyword">return</span> controller.stream;<br>&#125;<br><br>Future&lt;<span class="hljs-built_in">int</span>&gt; listenOn(Stream&lt;<span class="hljs-built_in">int</span>&gt; stream) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">var</span> completer = Completer&lt;<span class="hljs-built_in">int</span>&gt;();<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//监听Stream</span><br>  stream.listen((event) &#123;<br>    sum += event;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sum:<span class="hljs-subst">$sum</span>, event:<span class="hljs-subst">$event</span>&#x27;</span>);<br>  &#125;, onDone: () =&gt; completer.complete(sum));<br>  <span class="hljs-keyword">return</span> completer.future;<br>&#125;<br>Future&lt;<span class="hljs-keyword">void</span>&gt; onInit() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">super</span>.onInit();<br>  <span class="hljs-keyword">var</span> stream = countStream(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">await</span> listenOn(stream);<br>  <span class="hljs-built_in">print</span>(sum);<span class="hljs-comment">//55</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Stream的组成"><a href="#Stream的组成" class="headerlink" title="Stream的组成"></a>Stream的组成</h2><p>Flutter中的Stream处理，主要涉及三类对象，以发布订阅模式的角度去看的话，可以分为<strong>发布者StreamController</strong>、<strong>数据通道Stream</strong>、<strong>订阅者StreamSubscription</strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> controller = StreamController&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>  Stream&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">get</span> stream =&gt; controller.stream;<br>  StreamSubscription&lt;<span class="hljs-built_in">int</span>&gt;? _subscription;<br><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    _subscription = stream.listen((event) &#123;<br>      <span class="hljs-built_in">print</span>(event);<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>      controller.add(i);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    _subscription?.cancel();<br>    _subscription = <span class="hljs-keyword">null</span>;<br>    controller.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个<code>StreamController</code>都对应着一个<code>Stream</code>，当<code>Stream</code>被订阅时，会得到一个<code>StreamSubscription</code>对象。上面代码简单的使用了Stream并展示了他们的关系，但是他们内部的原理是怎么样了，事件从发布到消费的过程又是怎样的，可以通过数据流向图来看到。</p><h3 id="数据流向图"><a href="#数据流向图" class="headerlink" title="数据流向图"></a>数据流向图</h3><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/af5231d18e074da9b3b6b482804046ab%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="Stream (1).png"></p><p>在事件处理上：<code>Stream</code>在被订阅时，会创建<code>StreamSubscription</code>，并将其中的<code>onData</code>等事件处理的回调传给<code>StreamSubscription</code>。</p><p>在事件输入输出上：<code>StreamController</code>通过<code>add</code>方法输入事件后，先判断此时是否存在订阅者<code>StreamSubscription</code>，如果存在则调用<code>StreamSubscription</code>的<code>onData</code>处理，不存在就先存到<code>_pendingEvents</code>里，等到下次<code>StreamSubscription</code>出现了再向它输出事件。</p><p>可以看到，<code>StreamController</code> 在整个事件流向的处理中肩负着最重要的使命，它控制着事件如何输入和输出，<code>StreamSubscription</code>负责处理输出到这里的事件，<code>Stream</code>在得到<code>StreamSubscription</code>后就完成了它的使命选择“退隐山林”。</p><p>这么讲可能还有点“干”，为了更直观的介绍他们各自的职责，接下来我们从他们定义的接口出发，去思考他们都能做哪些事件。为了方便呈现，我只取其中最关键的部分。</p><h3 id="StreamController-1"><a href="#StreamController-1" class="headerlink" title="StreamController"></a>StreamController</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">class</span> <span class="hljs-title">StreamController</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">StreamSink</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// stream 流</span><br>  Stream&lt;T&gt; <span class="hljs-keyword">get</span> stream;<br>  <br>  <span class="hljs-comment">// 流状态的回调</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onListen; <span class="hljs-comment">// 被监听</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onPause; <span class="hljs-comment">// 流暂停</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onResume; <span class="hljs-comment">// 流恢复</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>()? onCancel; <span class="hljs-comment">// 流取消/关闭</span><br>  <br>  <span class="hljs-comment">// 流状态</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isClosed;<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isPaused;<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> hasLitener; <span class="hljs-comment">// 当前流是否有订阅者</span><br>  <br>  <span class="hljs-comment">// 监听 source，转发给 stream</span><br>  Future addStream(Stream&lt;T&gt; source, &#123;<span class="hljs-built_in">bool?</span> cancelOnError&#125;);<br>  <br>  <span class="hljs-comment">// 往流里面添加事件</span><br>  <span class="hljs-keyword">void</span> add(T event);<br>  <span class="hljs-keyword">void</span> addError(<span class="hljs-built_in">Object</span> error, [StackTrace? stackTrace]);<br>  Future close(); <span class="hljs-comment">// 关闭流</span><br>  <br>  <span class="hljs-comment">// 输出事件</span><br>  <span class="hljs-comment">// 以下这三个接口在 _StreamControllerBase 中</span><br>  <span class="hljs-keyword">void</span> _sendData(T data);<br>  <span class="hljs-keyword">void</span> _sendError(<span class="hljs-built_in">Object</span> error, StackTrace stackTrace);<br>  <span class="hljs-keyword">void</span> _sendDone();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>1.<code>StreamController</code>负责管理事件流的状态，当状态变化时，会触发到相应的回调(onListen/onPause等)。</p></li><li><p>2.<code>StreamController</code>负责事件的输入，输入的方式有两种，一种是事件接口<code>add</code>、<code>addError</code>；另外一种是通过监听其它的<code>Stream</code>；同时事件也分为两种，一种是正常事件，一种是错误事件。</p></li><li><p>3.<code>StreamController</code>能关闭这个事件流通道，会产生一个<code>onDone</code>事件。</p></li><li><p>4.<code>StreamController</code>负责事件的输出，不同的输入对应不同的输出。</p></li></ul><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">mixin</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <br>  <span class="hljs-comment">// 是否地广播流，广播流允许多订阅</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isBroadcast =&gt; <span class="hljs-keyword">false</span>;<br>  <br>  <span class="hljs-comment">// 监听流变化，返回订阅者</span><br>  StreamSubscription&lt;T&gt; listen(<span class="hljs-keyword">void</span> onData(T event)?,<br>    &#123;<span class="hljs-built_in">Function?</span> onError, <span class="hljs-keyword">void</span> onDone()?, <span class="hljs-built_in">bool?</span> cancelOnError&#125;);<br>    <br>  <span class="hljs-comment">// 一系列 Stream 处理和变换操作</span><br>  <br>  Stream&lt;T&gt; where(<span class="hljs-built_in">bool</span> test(T event)) &#123; ... &#125;<br>  Stream&lt;S&gt; map&lt;S&gt;(S convert(T event)) &#123; ... &#125;<br>  Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; convert(T event)) &#123; ...&#125;<br>  Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt;? convert(T event)) &#123; ... &#125;<br>  Stream&lt;T&gt; handleError(<span class="hljs-built_in">Function</span> onError, &#123;<span class="hljs-built_in">bool</span> test(error)?&#125;) &#123; ... &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>1.listen方法可以订阅Stream事件流，返回当前订阅者，并把listen方法中的onData等方法注册到当前订阅者中。</p></li><li><p>2.Stream有很多过滤转换等语法糖方法。</p></li></ul><h3 id="StreamSubscription"><a href="#StreamSubscription" class="headerlink" title="StreamSubscription"></a>StreamSubscription</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">class</span> <span class="hljs-title">StreamSubscription</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <br>  <span class="hljs-comment">// 监听数据变化</span><br>  <span class="hljs-keyword">void</span> onData(<span class="hljs-keyword">void</span> handleData(T data)?);<br>  <span class="hljs-keyword">void</span> onError(<span class="hljs-built_in">Function?</span> handleError);<br>  <span class="hljs-keyword">void</span> onDone(<span class="hljs-keyword">void</span> handleDone()?);<br><br>  <span class="hljs-comment">// 暂停/恢复 监听</span><br>  <span class="hljs-keyword">void</span> pause([Future&lt;<span class="hljs-keyword">void</span>&gt;? resumeSignal]);<br>  <span class="hljs-keyword">void</span> resume();<br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isPaused;<br>  <br>  <span class="hljs-comment">// 取消监听</span><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; cancel();<br>  <span class="hljs-comment">// 转成 Future 对象，监听流结束事件</span><br>  Future&lt;E&gt; asFuture&lt;E&gt;([E? futureValue]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>1.<code>StreamSubscription</code>作为事件输出端，负责事件的输出处理。</li><li>2.<code>StreamSubscription</code>也能对自己的订阅行为进行暂停、恢复或取消等动作。</li></ul><h2 id="Stream的分类"><a href="#Stream的分类" class="headerlink" title="Stream的分类"></a>Stream的分类</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>Stream在输入端可以分为同步流和异步流:</p><p><code>StreamController</code>的工厂方法中，通过<code>sync</code>可以指定同步或者异步。同步和异步的区别是：<strong>事件输入后是否会立即输出。</strong></p><p>同步流在事件输入后立刻执行<code>onData</code>，异步流在事件输入后注册一个异步事件，等到当前<code>EventLoop</code>中的同步事件处理后触发<code>onData</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">factory</span> StreamController(<br>    &#123;<span class="hljs-keyword">void</span> onListen()?,<br>    <span class="hljs-keyword">void</span> onPause()?,<br>    <span class="hljs-keyword">void</span> onResume()?,<br>    FutureOr&lt;<span class="hljs-keyword">void</span>&gt; onCancel()?,<br>    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">sync</span> = <span class="hljs-keyword">false</span>&#125;) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">sync</span><br>      ? _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)<br>      : _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);<br>&#125;<br></code></pre></td></tr></table></figure><p>在实现上看，<code>_SyncStreamController</code>最终输出时使用的是<code>_SyncStreamControllerDispatch</code>，<code>_AsyncStreamController</code>使用的是<code>_AsyncStreamControllerDispatch</code>。</p><p>两者在输出处理不同，<code>_SyncStreamControllerDispatch</code>调用的是<code>subscription</code>的<code>_add</code>方法，<code>_AsyncStreamControllerDispatch</code>调用的是<code>subscription</code>的<code>_addPending</code>方法。<code>_addPending</code>会先将事件存到队列里，同时如果队列没有在跑就开启队列的处理，通过<code>scheduleMicrotask</code>对事件进行异步处理，处理完当前事件继续处理队列时的其它事件，直到队列清空。</p><h3 id="广播和非广播"><a href="#广播和非广播" class="headerlink" title="广播和非广播"></a>广播和非广播</h3><p>Stream在输出端可以分为两类：</p><ul><li>单订阅流或者叫非广播流（Single Subscription），这种Stream最多只能有一个监听器（Listener）</li><li>多订阅流或者叫广播流（Broadcast），这种流可以有多个监视器监听（Listener）</li></ul><p>上述代码中生产的是非广播流，广播流通过<code>StreamController.broadcast</code>方法创建。<strong>广播和非广播的区别是是否允许多次订阅。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">factory</span> StreamController.broadcast(<br>    &#123;<span class="hljs-keyword">void</span> onListen()?, <span class="hljs-keyword">void</span> onCancel()?, <span class="hljs-built_in">bool</span> <span class="hljs-keyword">sync</span> = <span class="hljs-keyword">false</span>&#125;) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">sync</span><br>      ? _SyncBroadcastStreamController&lt;T&gt;(onListen, onCancel)<br>      : _AsyncBroadcastStreamController&lt;T&gt;(onListen, onCancel);<br>&#125;<br></code></pre></td></tr></table></figure><p>非广播<code>StreamController</code>继承自<code>_StreamController</code>，广播<code>StreamController</code>继承自<code>_BroadcastStreamController</code>，两者的区别可以通过<code>_subscribe</code>的实现体现。<code>_StreamController</code>的实现如下，当重复订阅后会直接抛出 StateError 异常。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">StreamSubscription&lt;T&gt; _subscribe(<span class="hljs-keyword">void</span> onData(T data)?, <span class="hljs-built_in">Function?</span> onError,<br>    <span class="hljs-keyword">void</span> onDone()?, <span class="hljs-built_in">bool</span> cancelOnError) &#123;<br>  <span class="hljs-keyword">if</span> (!_isInitialState) &#123;<br>    <span class="hljs-keyword">throw</span> StateError(<span class="hljs-string">&quot;Stream has already been listened to.&quot;</span>);<br>  &#125;<br>  _ControllerSubscription&lt;T&gt; subscription = _ControllerSubscription&lt;T&gt;(<br>      <span class="hljs-keyword">this</span>, onData, onError, onDone, cancelOnError);<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> subscription;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_BroadcastStreamController</code>里面有两个对象<code>_firstSubscription</code>、<code>_lastSubscription</code>，<code>_BroadcastSubscription</code>是双向链表结构。当需要输出事件时，通过整个链表，通知所有的订阅进行消息的处理。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">_BroadcastSubscription&lt;T&gt;? _firstSubscription;<br>_BroadcastSubscription&lt;T&gt;? _lastSubscription;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Stream</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS制作framework</title>
    <link href="/2023/06/02/iOS%E5%88%B6%E4%BD%9CFramework/"/>
    <url>/2023/06/02/iOS%E5%88%B6%E4%BD%9CFramework/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言：因为公司业务需求最近要开发一版蓝牙SDK供下游使用，说来惭愧iOS开发这么久，对于如何打包framework倒是知之甚少，所以写下这篇文章作为记录。</p></blockquote><h3 id="1-新建Framework"><a href="#1-新建Framework" class="headerlink" title="1. 新建Framework"></a>1. 新建Framework</h3><p>1.1 新建iOS Project，如下图所示选择iOS-Framework,名字可以随便取，我新建项目的名称为<code>LTTestKit</code><br><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602140353401.png" alt="image-20230602140353401"></p><p>如果上面不是选择iOS系统，而是macOS或者其它的系统，可在Xcode中【Targets】-&gt;【Build Settings】-&gt;【Base SDK】中切换为iOS系统，如下图所示。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602140816108.png" alt="image-20230602140816108"></p><p>接下修改<code>Mach-O Type</code>为Static Library，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602141019415.png" alt="image-20230602141019415"></p><h3 id="2-公开头文件"><a href="#2-公开头文件" class="headerlink" title="2.公开头文件"></a>2.公开头文件</h3><p>新建一个测试类，随便什么都行，我这边新建了一个打印的log的类，内容如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602141717450.png" alt="image-20230602141717450"></p><p>然后选择Target-BuildPhases，将需要公开的头文件拖到public中，此处我将LTPrintLog.h从Private拖到Public中。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602142257748.png" alt="image-20230602142257748"></p><p>另外公开头文件还有另外一种方法，选中头文件在右边栏中选择Public，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602143049697.png" alt="image-20230602143049697"></p><h3 id="3-修改项目头文件"><a href="#3-修改项目头文件" class="headerlink" title="3. 修改项目头文件"></a>3. 修改项目头文件</h3><p>找到项目的同名的头文件，把Public中的头文件导入到项目头文件里（项目同名的头文件，系统自动生成）</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602143200829.png" alt="image-20230602143200829"></p><h3 id="4-创建Aggregate-Target"><a href="#4-创建Aggregate-Target" class="headerlink" title="4.创建Aggregate Target"></a>4.创建Aggregate Target</h3><p>新建target，步骤如下图所示：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/%E6%88%AA%E5%B1%8F2023-06-02%2014.46.44.png" alt="截屏2023-06-02 14.46.44"></p><p>接下来选择Other -&gt; Aggregate，名字也随便起。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602152613079.png" alt="image-20230602152613079"></p><p>选中生成的Aggregate，为其添加依赖：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602152914250.png" alt="image-20230602152914250"></p><p>点击Target Dependencies下方的“+”，选中最开始创建的Framework对应的Target，点击“add”即可。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602152955367.png" alt="image-20230602152955367"></p><h3 id="5-修改Target的Scheme"><a href="#5-修改Target的Scheme" class="headerlink" title="5.修改Target的Scheme"></a>5.修改Target的Scheme</h3><p>如下图操作，选择EditScheme：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602153056002.png" alt="image-20230602153056002"></p><p>分别把两个Target的Run模式的Build Configuration改为Release。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602153223699.png" alt="image-20230602153223699"></p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602153246777.png" alt="image-20230602153246777"></p><h3 id="6-创建打包脚本"><a href="#6-创建打包脚本" class="headerlink" title="6.创建打包脚本"></a>6.创建打包脚本</h3><p>选择聚合Target，点击左上角的<code>+</code>号，选中<code>New Run Script Phase</code></p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/%E6%88%AA%E5%B1%8F2023-06-02%2015.35.09.png" alt="截屏2023-06-02 15.35.09"></p><p>在Run Script中添加如下脚本。脚本的作用是将模拟器包和真机包合并成一个聚合包，并将聚合包放在项目根目录下的Products文件夹中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ &quot;$&#123;ACTION&#125;&quot; = &quot;build&quot; ]<br>then<br>INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.framework<br> <br>DEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.framework<br> <br>SIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.framework<br> <br> <br>if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]<br>then<br>rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;<br>fi<br> <br>mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;<br> <br>cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">ditto <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DEVICE_DIR&#125;</span>/Headers&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;INSTALL_DIR&#125;</span>/Headers&quot;</span></span><br> <br>lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot;<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">open <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DEVICE_DIR&#125;</span>&quot;</span></span><br>open &quot;$&#123;SRCROOT&#125;/Products&quot;<br>fi<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602153705194.png" alt="image-20230602153705194"></p><h3 id="7-生成framework"><a href="#7-生成framework" class="headerlink" title="7.生成framework"></a>7.生成framework</h3><p>先选择Framework对应的Target分别在模拟器跟真机上都run一遍。这里分别选择了iPhone 14 Pro跟Any iOS Device（也可选择自己的真机）。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602154013756.png" alt="image-20230602154013756"></p><p>然后切换<code>LTTestKitAggregate</code>也运行一遍</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602154132268.png" alt="image-20230602154132268"></p><p>之后会自动弹出Finder，打好的framework就已经生成成功</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602154302178.png" alt="image-20230602154302178"></p><h3 id="8-检查Framework有效性。"><a href="#8-检查Framework有效性。" class="headerlink" title="8.检查Framework有效性。"></a>8.检查Framework有效性。</h3><p>打开终端，进入到LTTestKit.framework所在目录。利用lipo命令输出.framework下的LTTestKit文件信息。如下所示：lipo -info LTTestKit，显示为fat file，则表明是模拟器和真机的聚合包。fat file，顾名思义，胖文件。相应的，非聚合包就是瘦文件，则输出Non-fat file: LMBaseKit is architecture: arm64之类的</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230602154629949.png" alt="image-20230602154629949"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>做完这些步骤，Framework的生成工作就告一段落了，如何测试生成的Framework是否能用，只需要新建一个项目将生成的Framework拖入项目，导入头文件，调用Framework中的方法，查看是否执行。如果成功执行说明执行反之则出了问题。这里就不延时Framework的测试了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国区如何使用土耳其区iCloud</title>
    <link href="/2023/04/22/%E5%9B%BD%E5%8C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9C%9F%E8%80%B3%E5%85%B6%E5%8C%BAiCloud/"/>
    <url>/2023/04/22/%E5%9B%BD%E5%8C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9C%9F%E8%80%B3%E5%85%B6%E5%8C%BAiCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="国区如何使用土耳其区iCloud"><a href="#国区如何使用土耳其区iCloud" class="headerlink" title="国区如何使用土耳其区iCloud"></a>国区如何使用土耳其区iCloud</h1><blockquote><p>最近土耳其的汇率暴跌，现在iCloud200GB折合人民币只要7元，对比我现在的21感觉划算很多，故尝试一下土区账号邀请进家庭组省钱的方式。</p></blockquote><h2 id="一-注册iCloud土耳其区账号"><a href="#一-注册iCloud土耳其区账号" class="headerlink" title="一 注册iCloud土耳其区账号"></a>一 注册iCloud土耳其区账号</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>首先要注册一个新的iCloud账号用作土区账号，邮箱啥的没有要求，这是iCloud注册地址:<a href="https://www.icloud.com/">iCloud</a>，进去后点击创建Apple ID</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421173416307.png" alt="image-20230421173416307" style="zoom: 33%;" /><p>国家一定要选择土耳其</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421173937298.png" alt="image-20230421173937298" style="zoom:33%;" /><p>邮箱需要使用没有注册Apple ID的账号</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421173902533.png" alt="image-20230421173902533" style="zoom:33%;" /><p>可以使用没注册过苹果账号的国内手机</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421174016745.png" alt="image-20230421174016745" style="zoom:33%;" /><h3 id="添加付款信息"><a href="#添加付款信息" class="headerlink" title="添加付款信息"></a>添加付款信息</h3><p>注册成功后，要在<a href="https://www.icloud.com/">iCloud</a>上登录，然后点击右上角进入管理AppleID 页面</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421174211896.png" alt="image-20230421174211896" style="zoom: 50%;" /><p>进入后选择付款方式</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421174757335.png" alt="image-20230421174757335" style="zoom:50%;" /><p>如下图，付款方式一定要为空，账单寄送地址和派送地址都要填，必须是标准土耳其地址；</p><p><strong>这一步非常重要，如果账单地址和派送地址不对，付款的时候会弹框，所以必须要把地址填好，一个格子都别落下，用英文名</strong></p><p>下面附几个土耳其的地址：</p><pre><code class="hljs">-  **[土耳其外交机构地址大全](https://www.dashiguan.net/turkey-diplomatic-institutions/)** -  **[土耳其地址生成器](https://www.meiguodizhi.com/tr-address)**</code></pre><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421175436417.png" alt="image-20230421175436417" style="zoom:50%;" /><p>下面的是我填的地址</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230421180216922.png" alt="image-20230421180216922"></p><p>可以使用我的地址：</p><ul><li><p>Konak, Veysel Çk. No:97, 35638 Konak/İzmir, Turkey（第一行）</p></li><li><p>Konak, Veysel Çk. No:97, 35638 Konak/İzmir, Turkey（第二行）</p></li><li><p>35638（第三行）</p></li><li><p>İzmir（第四行）</p></li><li><p>536-3796416（电话）</p></li></ul><h3 id="登录账号"><a href="#登录账号" class="headerlink" title="登录账号"></a>登录账号</h3><p>最好找一台闲置的苹果设备，登录这个账号。</p><h2 id="二-加入家庭组"><a href="#二-加入家庭组" class="headerlink" title="二 加入家庭组"></a>二 加入家庭组</h2><p>加入家庭组有两种办法，一种是将土耳其账号作为主账号拉入其他账号，另一种是将土区账号拉入已有家庭组，我因为现在的账号已经在家庭共享所以选后一种方式，并且后一种方式更方便一点也不会影响到其他账号。</p><h3 id="使用隔空投送加入家庭组"><a href="#使用隔空投送加入家庭组" class="headerlink" title="使用隔空投送加入家庭组"></a>使用隔空投送加入家庭组</h3><p>首先要保证土区账号设备和主账号设备都开启了隔空投送并且是所有人连接，开启步骤</p><ul><li>设置 &gt; 通用 &gt; 隔空投送 &gt; 所有人</li></ul><p>接下来使用主账号设备邀请土区账号，将两个设备放在一起，主账号设备操作，步骤如下</p><ul><li>设置 &gt; 家庭共享 &gt; 右上角添加图标&gt; 邀请他人&gt; 隔空投送</li></ul><img src="/Users/lee/Downloads/IMG_42F804DE76B4-1.jpeg" alt="IMG_42F804DE76B4-1" style="zoom:33%;" /><p>然后土区账号设备就会弹出邀请信息，直接加入就行。</p><h2 id="三-充值土区苹果礼品卡"><a href="#三-充值土区苹果礼品卡" class="headerlink" title="三 充值土区苹果礼品卡"></a>三 充值土区苹果礼品卡</h2><p>这一步算是比较难的一步，因为需要去土耳其礼品卡网站购买礼品卡并充值。现在比较常见的购买渠道是两个:</p><ul><li><p><a href="https://www.epin.com.tr/">EPiN</a></p><ul><li>只支持Master/VISA，快速稳定，但容易缺货，我使用的EPiN</li></ul></li><li><p><a href="https://www.oyunfor.com/">oyunfor</a></p><ul><li>除非只有银联卡，不然别用，偶尔抽风不稳定，onyunfor购买步骤可以看这篇文章<a href="https://zhuanlan.zhihu.com/p/602512116">Apple Store 土耳其礼品卡直购指南 - 知乎 (zhihu.com)</a></li></ul></li></ul><p>EPiN的购买步骤如下：</p><pre><code class="hljs">- 注册</code></pre><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422200333944.png" alt="image-20230422200333944"></p><p>如果有Google账号可以直接选Google账号登录，可以免去注册的烦恼，然后购买的时候填一个国内的手机号码就行，如果你没有Google账号就接着往下看</p><ul><li><p>填写注册信息，如果看不懂可以用浏览器翻译一下</p> <img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422200826615.png" alt="image-20230422200826615" style="zoom: 67%;" /></li><li><p>注册成功</p><p>出现这个页面就是注册成功了</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422200943000.png" alt="image-20230422200943000"></p></li><li><p>回到首页购买礼品卡</p></li></ul><p>​        <img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422201102452.png"></p><p>​         购买的时候记得选第二个选项，这个是信用卡购买，然后点击蓝色按钮<br>​     <img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422201200664.png" alt="image-20230422201200664"></p><ul><li><p>选择Master/Visa</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422201438158.png" alt="image-20230422201438158"></p></li><li><p>去支付，按照下面的图示操作就行</p></li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422201526436.png" alt="image-20230422201526436"></p><ul><li><p>填写付款信息</p><ul><li><p>这个有个问题，点击DEVAM按钮后有可能会出现跳转失败的情况，这个时候重新刷新一下就好</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422201853016.png" alt="image-20230422201853016"></p></li></ul></li></ul><p>​            这图片上的信息用过信用卡的应该都不陌生，照着信用卡信息填就行， 填好后点PAY</p><ul><li><p>支付认证</p><ul><li>没什么好说的看图就行,选中然后下一步</li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422202055177.png" alt="image-20230422202055177"></p><ul><li>输入验证码，提交 </li></ul></li></ul><p>​        <img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422202144131.png" alt="image-20230422202144131"></p><ul><li>​    购买成功，点击DEVAM</li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422202259128.png" alt="image-20230422202259128"></p><ul><li><p>订单中心</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422202359412.png" alt="image-20230422202359412"></p></li></ul><p>打码的地方就是礼品卡兑换码。</p><blockquote><p> <strong>如果没有礼品卡兑换码而是一串土耳其语，不用担心那是因为没货了，等有货里立马就会变成礼品卡兑换码，亲测这个时间大概五个小时左右</strong></p></blockquote><h2 id="四-兑换礼品卡"><a href="#四-兑换礼品卡" class="headerlink" title="四 兑换礼品卡"></a>四 兑换礼品卡</h2><ul><li><p>在登录土区账号的设备进入App Store，点击右上角头像，选择下图红框图</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422203143236.png" alt="image-20230422203143236"></p></li><li><p>输入兑换码</p><ul><li>点击下图红框处输入兑换码</li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422203328262.png" alt="image-20230422203328262"></p></li><li><p>兑换成功</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422203528099.png" alt="image-20230422203528099"></p></li></ul><h2 id="五-购买iCloud服务"><a href="#五-购买iCloud服务" class="headerlink" title="五 购买iCloud服务"></a>五 购买iCloud服务</h2><p>土区账号设备进入<strong>【设置】》【自己头像】》【iCloud】》【管理储存空间】》【更改储存空间方案】</strong></p><p>选择想要的iCloud存储大小，付款就行，付款时会自动使用礼品卡付款</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422204212685.png" alt="image-20230422204212685"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>如果兑换的时候不是成功页面，而是出现下面的弹框，那说明你的iCloud的账单地址和配送地址有问题，需要重写填写一个，附上<a href="https://www.meiguodizhi.com/tr-address">土耳其地址生成器 - 土耳其身份生成器 - 土耳其信用卡生成器 (meiguodizhi.com)</a>然后再去iCloud网页端去修改就可以了。</p></blockquote><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422204319900.png" alt="image-20230422204319900"></p><h2 id="六-把土区iCloud分享给其他家庭成员"><a href="#六-把土区iCloud分享给其他家庭成员" class="headerlink" title="六 把土区iCloud分享给其他家庭成员"></a>六 把土区iCloud分享给其他家庭成员</h2><h3 id="1-原主账号停止分享（如果之前已经有iCloud共享的话）"><a href="#1-原主账号停止分享（如果之前已经有iCloud共享的话）" class="headerlink" title="1.原主账号停止分享（如果之前已经有iCloud共享的话）"></a>1.原主账号停止分享（如果之前已经有iCloud共享的话）</h3><p> 如果之前家庭已经开通了国区的iCloud，且全部成员在共享使用，那你需要关闭原来购买的iCloud服务；</p><p>方法：先登录国区家长账号（就是原来做分享的那个国区账号），停用其他成员的国区iCloud分享：<strong>【设置】》【头像】》【家人共享】》【iCloud+】》【停止与家人共享】</strong></p><h3 id="2-土区账号把iCloud共享给家庭成员"><a href="#2-土区账号把iCloud共享给家庭成员" class="headerlink" title="2.土区账号把iCloud共享给家庭成员"></a>2.土区账号把iCloud共享给家庭成员</h3><p>不管你的土耳其账号是家长还是成员，都可以通过以下操作将iCloud服务分享给家庭的其他成员；<br>土区账号的苹果设备，进入【设置】》【自己头像】》【iCloud】》【与家人共享】<br>然后，就可以把土区账号的iCloud空间分享给家庭的其他成员使用了，做完这些的时候家庭的其他成员应该自动可以使用共享出来的iCloud了。</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422204844167.png" alt="image-20230422204844167"></p><h3 id="3-关闭主账号iCloud空间"><a href="#3-关闭主账号iCloud空间" class="headerlink" title="3.关闭主账号iCloud空间"></a>3.关闭主账号iCloud空间</h3><p>主账号如果之前共享过，现在可以降级成免费的5GB空间，然后再选择使用土区账号的iCloud空间就好了</p><p><strong>进入【设置】》【头像】》【iCloud】》【管理储存空间】》【更改储存方案】》【降级选项】》【选择5GB免费方案】</strong>即可。</p><p>然后再进入<strong>【设置】》【头像】》【iCloud】》【管理储存空间】》【更改储存空间方案】</strong>这时候会提示你是否使用土区账号共享的iCloud的选择是即可。</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/IMG_BE7B620D4B0B-1.jpeg" alt="IMG_BE7B620D4B0B-1" style="zoom:33%;" /><h3 id="4-验证当前共享账号"><a href="#4-验证当前共享账号" class="headerlink" title="4.验证当前共享账号"></a>4.验证当前共享账号</h3><p>查看方法：<strong>【设置】-【家人共享】-【订阅】</strong>，在已共享中查看iCloud+的空间<strong>是不是由土耳其账号提供</strong>。</p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/IMG_42F804DE76B4-1.jpeg" alt="IMG_42F804DE76B4-1" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230422210243940.png" alt="image-20230422210243940" style="zoom: 67%;" /><h2 id="七-结束"><a href="#七-结束" class="headerlink" title="七 结束"></a>七 结束</h2><p>到这里所有步骤就已经全部结束了，跟着做的话其实不难就是比较繁琐，最后祝大家都能成为土区人，有问题可以留言给我。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android学习笔记（四）Activity</title>
    <link href="/2023/04/17/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity/"/>
    <url>/2023/04/17/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><blockquote><p>Activity是Android四大组件之一，功能和用法与iOS中的ViewController相类似</p></blockquote><h2 id="Activity的启动和结束"><a href="#Activity的启动和结束" class="headerlink" title="Activity的启动和结束"></a>Activity的启动和结束</h2><p>从当前页面跳到新页面，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">startActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inent</span>(源页面.<span class="hljs-built_in">this</span>,目标页面.<span class="hljs-built_in">this</span>));<br></code></pre></td></tr></table></figure><p>从当前页面返回上一个页面，相当于关闭当前页面，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">finish();<br></code></pre></td></tr></table></figure><h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android学习笔记（三）图像显示</title>
    <link href="/2023/04/17/%20Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/"/>
    <url>/2023/04/17/%20Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h2><blockquote><p>本文将学习关于图像显示的几种控件，包括：专门用于显示图片的图像视图以及若干缩放类型效果，支持显示图片的按钮控件–图像按钮，如何在按钮上同事显示文本和图标等。</p></blockquote><h3 id="图像视图ImageView"><a href="#图像视图ImageView" class="headerlink" title="图像视图ImageView"></a>图像视图ImageView</h3><p>​        显示文本需要TextView，显示图像需要用ImageView。由于图像通常保存为单独的图片文件，音词需要把图像先放到res/drwable目录，然后再去引用该资源。XML文件通过属性android:src设置图片资源，属性值格式形如”@drawable/不含扩展名的图片名称”。添加src属性的ImageView标签示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_scale&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;220dp&quot;</span> </span><br><span class="hljs-tag">           <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/ic_launcher_background&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>若想在Java代码中设置图像视图的图片资源，可以调用ImageVIew控件的setImageResource方法，方法参数格式形如<code>R.drawable.不含扩展名的图片名称</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从布局文件中获取图像视图</span><br><span class="hljs-type">ImageView</span> <span class="hljs-variable">iv_scale</span> <span class="hljs-operator">=</span> findViewById(R.id.iv_scale);<br>iv_scale.setImageResource(R.drawable.ic_launcher_background);<span class="hljs-comment">//设置图像的图片资源</span><br></code></pre></td></tr></table></figure><h3 id="图像视图的缩放类型"><a href="#图像视图的缩放类型" class="headerlink" title="图像视图的缩放类型"></a>图像视图的缩放类型</h3><p>ImageView本身默认图片居中显示，若要改变图片的显示方式，可通过scaleType属性设置，属性值说明如下：</p><table><thead><tr><th>XML中的缩放类型</th><th>ScaleType类中的缩放类型</th><th>说明</th></tr></thead><tbody><tr><td>fitXY</td><td>FIT_XY</td><td>拉伸图片使其正好填满视图（图片可能被拉伸变形）</td></tr><tr><td>fitStart</td><td>FIT_START</td><td>保持宽高比例，拉伸图片使其位于视图上方或左侧</td></tr><tr><td>fitCenter</td><td>FIT_CENTER</td><td>保持宽高比例，拉伸图片使其位于视图中间</td></tr><tr><td>fitEnd</td><td>FIT_END</td><td>保持宽高比例，拉伸图片使其位于视图下方或右侧</td></tr><tr><td>center</td><td>CENTER</td><td>保持图片原尺寸，使其位于视图中间</td></tr><tr><td>centerCrop</td><td>CENTER_CROP</td><td>拉伸图片使其充满视图，并位于视图中间</td></tr><tr><td>centerInside</td><td>CENTER_INSIDE</td><td>保持宽高比例，缩小图片使其位于视图中间（只缩小不放大）</td></tr></tbody></table><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230417140107745.png" alt="image-20230417140107745"></p><h3 id="图像按钮ImageButton"><a href="#图像按钮ImageButton" class="headerlink" title="图像按钮ImageButton"></a>图像按钮ImageButton</h3><ul><li>ImageButton是显示图片的图像按钮，但它继承自ImageView并非Button</li><li>ImageButton和Button之间的区别有：<ul><li>Button既可展示文本也可显示图片，ImageButton只能显示图片不能显示文本。</li><li>ImageButton上的图像可以比例缩放，Button通过背景设置的图像会拉伸变形。</li><li>Button只能靠背景显示一张图片，而ImageButton可分别在前景和背景显示图片，从而实现两张图片叠加的效果。</li></ul></li></ul><h3 id="ImageButton的使用场合"><a href="#ImageButton的使用场合" class="headerlink" title="ImageButton的使用场合"></a>ImageButton的使用场合</h3><ul><li>某些无法打出来的字符，或者某些文字以特殊字体展示等都可以切图放入ImageButton。</li><li>ImageButton与ImageView的区别：<ul><li>ImageButton有默认的按钮背景，ImageView默认无背景</li><li>ImageButton默认的缩放类型为center，二ImageView默认的缩放类型为fitCenter。</li></ul></li></ul><h3 id="同时展示文本与图像"><a href="#同时展示文本与图像" class="headerlink" title="同时展示文本与图像"></a>同时展示文本与图像</h3><ul><li>同时展示文本与图像的可能途径包括：<ol><li>利用LineLayout对ImageView和TextView组合布局。</li><li>通过按钮控件Button的drawable***属性设置文本周围的图标<ul><li>drawableTop：指定文字上方的图片</li><li>drawableBottom：指定文字下方的图片</li><li>drawableLeft：值定文字左边的图片</li><li>drawableRight：指定文字右边的图片</li><li>drawablePadding ：指定图片与文字的间距</li></ul><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230417171722612.png" alt="image-20230417171722612"></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android学习笔记（二） 按钮控件Button</title>
    <link href="/2023/04/14/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/04/14/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="按钮控件Button"><a href="#按钮控件Button" class="headerlink" title="按钮控件Button"></a>按钮控件Button</h2><blockquote><p>本节学习Android中按钮的常见用法</p></blockquote><p>除了文本视图以外，Button也是一种基础控件。Button是由TextView派生而来，所以它可以使用文本视图的属性和方法。不同的是Button拥有默认的按钮背景，而TextView无背景；Button的内部文本默认居中对齐，而TextView的内部文本默认左对齐。此外还要需要额外注意textAllCaps与onClick两个属性，分别介绍如下:</p><h3 id="1-textAllCaps属性"><a href="#1-textAllCaps属性" class="headerlink" title="1. textAllCaps属性"></a>1. textAllCaps属性</h3><p>对于TextView来说，设置什么就显示什么，但是对于Button来说不管设置大写还是小写字符控件都真是转成大写展示。因为给Button标签补充textAllCaps属性，该属性默认为true表示全部转为大写，设置为false表示不展示大写。</p><p>代码示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World&quot;</span> <span class="hljs-attr">android:textAllCaps</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414143212597.png" alt="image-20230414143212597"></p><h3 id="2-onClick属性"><a href="#2-onClick属性" class="headerlink" title="2.  onClick属性"></a>2.  onClick属性</h3><p> onClick对于前端开发应该都不陌生，在Android中该属性的值是个方法名，也就是当前页面Java代码存在的一个方法：当用户点击按钮时，就自动调用该方法。</p><p>譬如下面的Button标签指定了onClick属性值为doClick,表示点击该按钮后会出发Java代码中的doClick方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_click_xml&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;doClick&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;直接指定点击方法&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_result&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;这里查看按钮的点击结果&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>与之对应的页面中的Java中需要增加doClick方法，方法部分代码示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// activity_button_style.xml中给btn_click_xml指定了点击方法doClick </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doClick</span><span class="hljs-params">(View view)</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您点击了按钮：%s&quot;</span>, DateUtil.getNowTime(), ((Button) view).getText()); <br>  tv_result.setText(desc); <br>  <span class="hljs-comment">// 设置文本视图的文本内容 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>点击之前：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414145304173.png" alt="image-20230414145304173"></p><p>点击之后：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414145324222.png" alt="image-20230414145324222"></p><h3 id="3-点击事件和长按事件"><a href="#3-点击事件和长按事件" class="headerlink" title="3 点击事件和长按事件"></a>3 点击事件和长按事件</h3><p>​        虽然按钮控件能够在XML文件中通过onClick属性指定点击方法，但是方法的名称可以随便叫，既能叫doClick也能叫doTouch，甚至叫它doA或doB都没问题，这样很不利于规范化代码，倘若以后换了别人接手，就不晓得doA或doB是干什么用的。因此在实际开发中，不推荐使用Button标签的onClick属性，而是在代码中给按钮对象注册点击监听器。</p><p>​        所谓监听器，意思是专门监听控件的动作行为，它平时无所事事，只有控件发生了指定的动作，监听器才会触发开关去执行对应的代码逻辑。点击监听器需要实现接口View.OnClickListener，并重写onClick方法补充点击事件的处理代码，再由按钮调用setOnClickListener方法设置监听器对象。下面的代码就是给控件btn_click_single设置的监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">btn_click_single</span> <span class="hljs-operator">=</span> findViewById(R.id.btn_click_single);<br>btn_click_single.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyOnClickListener</span>);<br></code></pre></td></tr></table></figure><p>上面的点击监听器名为MyOnClickListener，它的定义代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOnClickListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListenter &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您点击了按钮：%s&quot;</span>， DateUtil.getNowTime(),((Button)v).getText());<br>    tv_result.setText(desc);<span class="hljs-comment">//设置文本视图文本内容</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后点击按钮效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414150527483.png" alt="image-20230414150527483"></p><p>​        如果一个页面只有一个按钮，单独定义新的监听器倒也无妨，可是如果存在许多按钮，每个按钮都定义自己的监听器，那就劳民伤财了。对于同时监听多个按钮的情况，更好的办法是注册统一的监听器，也就是让当前页面实现接口View.OnClickListener，如此一来，onClick方法便写在了页面代码之内。因为是统一的监听器，所以onClick内部需要判断是哪个按钮被点击了，也就是利用视图对象的getId方法检查控件编号，完整的onClick代码举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123; <span class="hljs-comment">// 点击事件的处理方法</span><br>  <span class="hljs-keyword">if</span> (v.getId() == R.id.btn_click_public) &#123; <br>    <span class="hljs-comment">// 来自于按钮btn_click_public </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您点击了按钮：%s&quot;</span>, DateUtil.getNowTime(), ((Button) v).getText()); <br>    tv_result.setText(desc); <span class="hljs-comment">// 设置文本视图的文本内容 </span><br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>当然该页面的onCreate内部别忘了调用按钮对象的setOnClickListener方法，把按钮的点击监听器设置成当前页面，设置代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从布局文件中获取名为btn_click_public的按钮控件 </span><br><span class="hljs-type">Button</span> <span class="hljs-variable">btn_click_public</span> <span class="hljs-operator">=</span> findViewById(R.id.btn_click_public); <br><span class="hljs-comment">// 设置点击监听器，一旦用户点击按钮，就触发监听器的onClick方法 </span><br>btn_click_public.setOnClickListener(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>重新运行App后，点击第二个按钮发现onClick方法也可以正常执行了：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414161238060.png" alt="image-20230414161238060"></p><p>除了点击事件，Button还提供长按事件，当控件被按住超过500毫秒即可触发长按事件。监听长按事件，可以使用setOnLongClickListener监听器。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从布局文件中获取名为btn_click_public的按钮控件 </span><br><span class="hljs-type">Button</span> <span class="hljs-variable">btn_longclick_public</span> <span class="hljs-operator">=</span> findViewById(R.id.btn_longclick_public); <br><span class="hljs-comment">// 设置长按监听器，一旦用户长按按钮，就触发监听器的onLongClick方法 </span><br>btn_longclick_public.setOnLongClickListener(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>以上代码把长按监听器设置到当前页面，现在还需要实现对应的长按接口，并重写长按方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onLongClick</span><span class="hljs-params">(View v)</span> &#123;<br><span class="hljs-comment">// 长按事件的处理方法 </span><br><span class="hljs-keyword">if</span> (v.getId() == R.id.btn_longclick_public) &#123; <span class="hljs-comment">// 来自于按钮 btn_longclick_public</span><br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您长按了按钮：%s&quot;</span>, DateUtil.getNowTime(), ((Button) v).getText()); <br>  tv_result.setText(desc); <span class="hljs-comment">// 设置文本视图的文本内容 </span><br>&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行，效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414161831245.png" alt="image-20230414161831245"></p><p>值得注意的是，点击监听器和长按监听器不局限于按钮控件，其实它们都来源于视图基类View，凡是从View派生而来的各类控件，均可注册点击监听器和长按监听器。譬如文本视图TextView，其对象也能调用setOnClickListener方法与setOnLongClickListener方法，此时TextView控件就会响应点击动作和长按动作。因为按钮存在按下和松开两种背景，便于提示用户该控件允许点击，但文本视图默认没有按压背景，不方便判断是否被点击，所以一般不会让文本视图处理点击事件和长按事件。</p><h3 id="4-禁用和恢复按钮"><a href="#4-禁用和恢复按钮" class="headerlink" title="4 禁用和恢复按钮"></a>4 禁用和恢复按钮</h3><p>​        Button可以存在静止点击的状态，需要设置属性<code>android:enabled</code>为true可以点击反之不可点击。在Java代码中可以通过setEnabled设置按钮的可用状态。</p><p>​        接下来通过一段代码演示按钮的禁用和启用状态。通过两个button来控制测试按钮的状态。代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_enable&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;启用测试按钮&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_disable&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;禁用测试按钮&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_test&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;测试按钮&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#888888&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_result&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">&quot;5dp&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;这里查看测试按钮的点击结果&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414162650933.png" alt="image-20230414162650933"></p><p>在Java代码中给三个按钮注册监听器，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为按钮控件的setOnClickListener方法来源于View基类，所以也可对findViewById得到的视图直 接设置点击监听器 </span><br>findViewById(R.id.btn_enable).setOnClickListener(<span class="hljs-built_in">this</span>); findViewById(R.id.btn_disable).setOnClickListener(<span class="hljs-built_in">this</span>); <br>btn_test = findViewById(R.id.btn_test); <span class="hljs-comment">// 获取名叫btn_test的按钮控件 </span><br>btn_test.setOnClickListener(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 设置btn_test的点击监听器</span><br></code></pre></td></tr></table></figure><p>同时重写页面的onClick方法，分别处理3个按钮的点击事件，修改之后的onClick代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123; <br>  <span class="hljs-comment">// 点击事件的处理方法 </span><br>  <span class="hljs-comment">// 由于多个控件都把点击监听器设置到了当前页面，因此公共的onClick方法内部需要区分来自于哪个 按钮 </span><br>  <span class="hljs-keyword">if</span> (v.getId() == R.id.btn_enable) &#123; <span class="hljs-comment">// 点击了按钮“启用测试按钮” </span><br>    btn_test.setTextColor(Color.BLACK); <span class="hljs-comment">// 设置按钮的文字颜色 </span><br>    btn_test.setEnabled(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 启用当前控件 </span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.getId() == R.id.btn_disable) &#123; <span class="hljs-comment">// 点击了按钮“禁用测试按钮” </span><br>    btn_test.setTextColor(Color.GRAY); <span class="hljs-comment">// 设置按钮的文字颜色 </span><br>    btn_test.setEnabled(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 禁用当前控件</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.getId() == R.id.btn_test) &#123; <span class="hljs-comment">// 点击了按钮“测试按钮” </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s 您点击了按钮：%s&quot;</span>, DateUtil.getNowTime(), ((Button) v).getText()); <br>    tv_result.setText(desc); <span class="hljs-comment">// 设置文本视图的文本内容 </span><br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>最后编译运行App，点击了“启用测试按钮”之后，原本置灰的测试按钮btn_test恢复正常的黑色文本，点击该按钮发现界面有了反应，具体效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414162935262.png" alt="image-20230414162935262"></p><p>对比上面两图，可以观察禁用和启用两个模式的区别。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android学习笔记（一）Android中的常用布局</title>
    <link href="/2023/04/14/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Android%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/"/>
    <url>/2023/04/14/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Android%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的常用布局"><a href="#Android中的常用布局" class="headerlink" title="Android中的常用布局"></a>Android中的常用布局</h1><h2 id="1线性布局-LinearLayout"><a href="#1线性布局-LinearLayout" class="headerlink" title="1线性布局 LinearLayout"></a>1线性布局 LinearLayout</h2><p>​        线性布局是Android的基本布局，可以水平排列<code>horizontal</code>和垂直排列<code>vertical</code>通过<code>android:orientation</code>来设置方向，系统默认布局为水平方向排列，这跟iOS中的<code>VStack</code>,<code>HStack</code>有些相似。<br>​        除了方向之外，线性布局还有一个权重概念，所谓权重就是指布局的子视图各自拥有多大的比例的宽高。占比多或是占比少通过属性<code>android:layout_weight</code>来设置。。不过视图有宽高两个方向，系统怎知layout_weight表示哪个方向的权重呢？所以这里有个规定，一旦设置了layout_weight属性值，便要求layout_width填0dp或者layout_height填0dp。如果layout_width填0dp，则layout_weight表示水平方向的权重，下级视图会从左往右分割线性布局；如果layout_height填0dp，则layout_weight表示垂直方向的权重，下级视图会从上往下分割线性布局。</p><p>​        按照左右均分的话，线性布局设置水平方向horizontal，且甲乙两视图的layout_width都填0dp，layout_weight都填1，此时横排的XML片段示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;横排第一个&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;横排第二个&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        按照上下均分的话，线性布局设置垂直方向vertical，且甲乙两视图的layout_height都填0dp，</p><p>layout_weight都填1，此时竖排的XML片段示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span> <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;竖排第一个&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span> <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;竖排第二个&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>具体界面如图</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414105040856.png" alt="image-20230414105040856"></p><h2 id="2-相对布局RelativeLayout"><a href="#2-相对布局RelativeLayout" class="headerlink" title="2 相对布局RelativeLayout"></a>2 相对布局RelativeLayout</h2><p>线性布局的子视图是顺序排列的，相对布局的视图位置是有其他视图决定的，学过iOS肯定不陌生，毕竟iOS大部分的布局都是相对布局。如果不设定下级视图的参照物，默认就在RelativeLayout的左上角。</p><table><thead><tr><th>相对位置的属性取值</th><th>相对位置说明</th></tr></thead><tbody><tr><td>layout_toLeftOf</td><td>当前视图在指定视图的左边</td></tr><tr><td>layout_toRrightOf</td><td>当前视图在指定视图的右边</td></tr><tr><td>layout_above</td><td>在指定视图的上方</td></tr><tr><td>layout_below</td><td>在指定视图的下方</td></tr><tr><td>layout_alignLeft</td><td>当前视图与指定视图左对齐</td></tr><tr><td>layout_alignRight</td><td>当前视图与指定视图右对齐</td></tr><tr><td>layout_alignTop</td><td>当前视图与指定视图顶对齐</td></tr><tr><td>layout_alignBottom</td><td>当前视图与指定视图底对齐</td></tr><tr><td>layout_centerInParent</td><td>当前视图在上级视图中间</td></tr><tr><td>layout_centerHorizontal</td><td>当前视图在上级视图的水平方向居中</td></tr><tr><td>layout_centerVertical</td><td>当前视图与上级视图垂直方向居中</td></tr><tr><td>layout_alignParentLeft</td><td>当前视图与上级视图左对齐</td></tr><tr><td>layout_alignParentRight</td><td>当前视图与上级视图右对齐</td></tr><tr><td>layout_alignParentTop</td><td>当前视图与上级视图顶对齐</td></tr><tr><td>layout_alignParentBottom</td><td>当前试图与上级视图底部对齐</td></tr></tbody></table><p>需要记住的属性大概就这么多，对比<code>masonry</code>好像确实有点多，不过见文知意也不需要特别去记。</p><p>xml代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;150dp&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ffffff&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在中间&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_center_horizontal&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_centerHorizontal</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在水平中间&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_center_vertical&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_centerVertical</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在垂直中间&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_parent_left&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_alignParentLeft</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我跟上级左边对齐&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_parent_right&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_alignParentRight</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我跟上级右边对齐&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_parent_top&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_alignParentTop</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我跟上级顶部对齐&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_parent_bottom&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_alignParentBottom</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我跟上级底部对齐&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_left_center&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_toLeftOf</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:layout_alignTop</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在中间左边&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_right_center&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_toRightOf</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:layout_alignBottom</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在中间右边&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_above_center&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_above</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:layout_alignLeft</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在中间上面&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_below_center&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:layout_alignRight</span>=<span class="hljs-string">&quot;@+id/tv_center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#eeeeee&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我在中间下面&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;11sp&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414112641418.png" alt="image-20230414112641418"></p><h2 id="3-网格布局"><a href="#3-网格布局" class="headerlink" title="3 网格布局"></a>3 网格布局</h2><p>​        虽然线性布局能在水平和垂直方向排列，但是它不支持多行多列的布局方式，所有要实现类似表格那样的多行多列形式，可以采用网格布局GridLayout。</p><p>​        网格布局默认从左往右，从上到下排列，它先从第一行从左往右放置子视图，塞满之后另起一行放置其余的子视图，如此循环往复直至放置完毕。为了判断能够容纳几行几列，网格视图新增以下属性<code>android:columnCount</code>与<code>android:rowCount</code>两个属性，<code>columnCount</code>指定列数，<code>rowCount</code>指定行数。</p><p>​        下面是网格布局的布局代码示例，它规定了一个两行两列的网格布局，且内部容纳四个文本视图。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 根布局为两行两列的网格布局，其中列数由columnCount指定，行数由rowCount指定 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">GridLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:columnCount</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">android:rowCount</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;180dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span> <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ffcccc&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;浅红色&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;180dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span> <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ffaa00&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;橙色&quot;</span><span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;180dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span> <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#00ff00&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;绿色&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;180dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span> <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#660066&quot;</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;深紫色&quot;</span> <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#000000&quot;</span> <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;17sp&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">GridLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/image-20230414132425562.png" alt="image-20230414132425562"></p><h2 id="4-滚动视图ScrollView"><a href="#4-滚动视图ScrollView" class="headerlink" title="4 滚动视图ScrollView"></a>4 滚动视图ScrollView</h2><p>滚动视图顾名思义就是可以滚动的视图，当内容超出手机展示界面时需滑动手机屏幕才能完整展示，但是一般的视图不支持自行滚动，这时就需要借助滚动视图。与线性布局类似，滚动视图也分为水平和垂直两类，其中垂直滚动视图为ScrollView，水平滚动视图为HorizontalScrollView，这与iOS倒是不同，iOS只有一个ScrollView，只是有个属性可以设置水平还是垂直。滚动视图使用不用复杂，主要注意一下3点：</p><ul><li><p>垂直滚动时，layout_width属性设置为match_parent,layout_height设置为wrap_content。</p></li><li><p>水平滚动时，layout_width属性设置为wrap_content,layout_height设置为match_parent.</p></li><li><p>滚动视图节点下必须且只能挂着一个子布局节点，否则会在运行时报错<code>Caused by： java.lang.IllegalStateException：ScrollView can host only one direct child</code>。</p></li></ul><p>下面是垂直滚动视图ScrollView和水平滚动HorizontalScrollView的代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span> <br>  <span class="hljs-comment">&lt;!-- HorizontalScrollView是水平方向的滚动视图，当前高度为200dp --&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">HorizontalScrollView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 水平方向的线性布局，两个子视图的颜色分别为青色和黄色 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;300dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#aaffff&quot;</span> /&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;300dp&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ffff00&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">HorizontalScrollView</span>&gt;</span> <br>  <span class="hljs-comment">&lt;!-- ScrollView是垂直方向的滚动视图，当前高度为自适应 --&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">ScrollView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span> <br>  <span class="hljs-comment">&lt;!-- 垂直方向的线性布局，两个子视图的颜色分别为绿色和橙色 --&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;400dp&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#00ff00&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;400dp&quot;</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ffffaa&quot;</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ScrollView</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行测试App，可知ScrollView在纵向滚动，而HorizontalScrollView在横向滚动。</p><p><em><strong>注意</strong></em>：有时ScrollView的实际内容不够充满整个屏幕，但是又想让它充满屏幕，如果把layout_height属性设为match_parent，结果还是不能充满，正确的做法是再增加一行属性<code>android:fillViewport</code>该属性为true表示允许充满视图窗口，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:layout_height=&quot;match_parent&quot; <br>android:fillViewport=&quot;true&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多个ssh秘钥导致Git push失败及其解决方案</title>
    <link href="/2023/04/13/%E5%A4%9A%E4%B8%AAssh%E7%A7%98%E9%92%A5%E5%AF%BC%E8%87%B4Git-push%E5%A4%B1%E8%B4%A5%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/04/13/%E5%A4%9A%E4%B8%AAssh%E7%A7%98%E9%92%A5%E5%AF%BC%E8%87%B4Git-push%E5%A4%B1%E8%B4%A5%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>自从上次更换Mac，导致Hexo文件丢失后居然已经N年没有写Blog，最近心血来潮打算重新开始拾起来，于是便新建了一个Hexo将以前的替换，重新开始，索性便将遇到的问题当做这个Blog的第一篇吧。</p><p><strong>解决方案请直接看最后，中间都是无用废话</strong></p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为向GitHub推送内容需要ssh秘钥，但是我本地已经有了gitlab的秘钥，我又不想替换于是便Google一下如何配置多个ssh秘钥，命令如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t rsa -f ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.别名 -C <span class="hljs-string">&quot;邮箱地址&quot;</span><br></code></pre></td></tr></table></figure><p>比如要生成GitHub的ssh就可以这样：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t rsa -f ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.github -C <span class="hljs-string">&quot;邮箱地址&quot;</span><br></code></pre></td></tr></table></figure><p>我看完命令后直接生成完秘钥就关闭网页，这就导致我后面的一系列踩坑，不过幸亏有ChatGPT让我的坑踩得容易多了， 当然这都是后话了。</p><p>然后我就继续搭建Blog，当本地预览没问题后，我<code>hexo d</code> 后终端开始报错：</p> <figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">git@github.com: Permission denied (publickey).<br>fatal: 无法读取远程仓库。<br><br>请确认您有正确的访问权限并且仓库存在。<br>FATAL &#123;<br>  <span class="hljs-attribute">err</span>: Error: Spawn failed<br>      at ChildProcess.&lt;anonymous&gt; (/Users/lee/blog/node_modules/hexo-util/lib/spawn<span class="hljs-variable">.js</span>:51:21)<br>      at ChildProcess<span class="hljs-variable">.emit</span> (node:events:390:28)<br>      at Process<span class="hljs-variable">.ChildProcess</span><span class="hljs-variable">._handle</span><span class="hljs-variable">.onexit</span> (node:internal/child_process:290:12) &#123;<br>    code: 128<br>  &#125;<br>&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo<span class="hljs-variable">.io</span>/docs/troubleshooting<span class="hljs-variable">.html</span><br></code></pre></td></tr></table></figure><p>继续使用<code>ssh -T git@github.com</code>发现并没有出现success，猜想可能是秘钥生成错误，但是检查一遍后发现并不是，继续使用<code>ssh -vT git@github.com</code>查看log，发现查找本地秘钥的时候并没有找到有别名的ssh秘钥，所以大概知道问题出在哪了。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>直接ChatGPT开问，它直接告诉我三条命令</p><ol><li>打开终端并运行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br></code></pre></td></tr></table></figure><ol><li>确保 ssh-agent 正在运行。如果输出显示了 “Agent pid” 和一个数字，则说明 ssh-agent 正在运行。如果没有输出，则说明 ssh-agent 没有启动，您需要重新运行上述命令。</li><li>将 SSH 私钥文件添加到 ssh-agent 中。运行以下命令：</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.github<br></code></pre></td></tr></table></figure><ol start="3"><li>复制您的 SSH 公钥。运行以下命令来复制您的公钥：</li></ol> <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pbcopy &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.github.pub<br></code></pre></td></tr></table></figure><p>确实解决了，但是重启iTerm后发现又不能push了，继续问<br><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/20230413183804.jpg"></p><p>AI直接让我改终端配置文件，然并无卵用，倒是陷入坑中跟ChatGPT聊天浪费不少时间。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>最后直接转换话题，问ChatGPT如何在Mac中配置多个ssh秘钥，给出结论和我开始的操作一样，不一样的是新增了config文件，真相大白，原因即是配置配置多个秘钥让Git可以识别不同的。</p><p>具体的方法如下：</p><p>在 Mac 上配置多个 SSH 秘钥的步骤如下：</p><ol><li>生成多个密钥对</li></ol><p>在终端中执行以下命令生成多个密钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@example.com&quot;</span> -f ~/.ssh/id_rsa_1<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@example.com&quot;</span> -f ~/.ssh/id_rsa_2<br></code></pre></td></tr></table></figure><p>其中 <code>-f</code> 参数指定了私钥和公钥的文件名，可以根据需要自定义。</p><ol><li>添加私钥到 SSH Agent</li></ol><p>执行以下命令将私钥添加到 SSH Agent：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add ~/.ssh/id_rsa_1<br>ssh-add ~/.ssh/id_rsa_2<br></code></pre></td></tr></table></figure><ol><li>配置 SSH 配置文件</li></ol><p>在 <code>~/.ssh/</code> 目录下创建 <code>config</code> 文件，并按照如下格式配置多个主机和对应的密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一个主机</span><br>Host host1<br>HostName example.com<br>User username<br>IdentityFile ~/.ssh/id_rsa_1<br><br><span class="hljs-comment"># 第二个主机</span><br>Host host2<br>HostName example.org<br>User username<br>IdentityFile ~/.ssh/id_rsa_2<br></code></pre></td></tr></table></figure><p>其中 <code>Host</code> 是主机别名，<code>HostName</code> 是主机名或 IP 地址，<code>User</code> 是登录用户名，<code>IdentityFile</code> 是对应的私钥文件路径。</p><ol><li>测试连接</li></ol><p>执行以下命令测试连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh host1<br>ssh host2<br></code></pre></td></tr></table></figure><p>如果连接成功，则表示配置成功。</p><p>这样就可以在 Mac 上使用多个 SSH 秘钥了。</p><p>经本人测试，重启终端后也可以正常使用。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>做完这一切后，我又找到那个只看了一半就关掉的如何配置多个秘钥的教程，发现后部分就是就是教你如何配置config的，真是被自己气死，看东西只看一半……</p><p>附上地址：<a href="https://blog.csdn.net/wxl1555/article/details/115682017">Mac如何生成并配置多个ssh秘钥_mac 创建多个ssh_牛长犇的博客-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>fixs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS使用AVPlayer及MPPlayer播放在线视频</title>
    <link href="/2016/11/01/iOS%E4%BD%BF%E7%94%A8AVPlayer%E5%8F%8AMPPlayer%E6%92%AD%E6%94%BE%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91/"/>
    <url>/2016/11/01/iOS%E4%BD%BF%E7%94%A8AVPlayer%E5%8F%8AMPPlayer%E6%92%AD%E6%94%BE%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在仿做一个APP，其中使用到视频流播放，原本是打算使用MPPlayer进行在线播放出来的，但是发现iOS9之后以及不在支持MP了，刚好也没怎么接触过AVPlyer借此机会刚好学习一番。因为AVPlayer所有控件都是需要自定义，如果只是简单的播放视频其实是不如MPPlayer方便的。</p></blockquote><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-简单点的MPPlayer"><a href="#1-简单点的MPPlayer" class="headerlink" title="1. 简单点的MPPlayer"></a>1. 简单点的MPPlayer</h3><ul><li>声明一个<code>MPMoviePlayerController </code> 的属性</li></ul> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">MPMoviePlayerController</span> *moviePlayer;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *moviePath;<span class="hljs-comment">//播放路径</span><br></code></pre></td></tr></table></figure><ul><li>懒加载</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (!_moviePlayer) &#123;<br>       _moviePlayer = [[<span class="hljs-built_in">MPMoviePlayerController</span> alloc]init];<br>       [_moviePlayer.view setFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-keyword">self</span>.view.bounds.size.width, <span class="hljs-keyword">self</span>.view.bounds.size.height/<span class="hljs-number">3</span>)];<br>       <span class="hljs-comment">//设置自动播放</span><br>       [_moviePlayer setShouldAutoplay:<span class="hljs-literal">NO</span>];<br>       <span class="hljs-comment">//设置源类型 因为新特性一般都是播放本地的小视频 所以设置源类型为file</span><br>       _moviePlayer.movieSourceType = <span class="hljs-built_in">MPMovieSourceTypeStreaming</span>;<br><br>       [<span class="hljs-keyword">self</span>.view addSubview:_moviePlayer.view];<br>   &#125;<br>   <span class="hljs-keyword">return</span> _moviePlayer;<br><br></code></pre></td></tr></table></figure><p>如果只是播放暂停之类的几乎是不需要自己做什么的，很简单。</p><ul><li>设置播放源<br>我是在<code>set</code>方法中设置的，不过这个都无所谓。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setMoviePath:(<span class="hljs-built_in">NSString</span> *)moviePath&#123;<br>    _moviePath = [moviePath <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-keyword">self</span>.moviePlayer.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> clearColor];<br>    <span class="hljs-comment">// 设置播放的路径</span><br>    <span class="hljs-keyword">self</span>.moviePlayer.contentURL = [<span class="hljs-built_in">NSURL</span> URLWithString:moviePath];<br>    [<span class="hljs-keyword">self</span>.moviePlayer prepareToPlay];<br>    [<span class="hljs-keyword">self</span>.moviePlayer play];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>viewDidLoad</code>调用</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.moviePath = <span class="hljs-string">@&quot;http://baobab.wdjcdn.com/1455782903700jy.mp4&quot;</span>;<br><br></code></pre></td></tr></table></figure><ul><li>大功告成</li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/1240-20230415203631768" alt="MPPlyer播放"></p><h3 id="2-主角AVPlayer"><a href="#2-主角AVPlayer" class="headerlink" title="2.主角AVPlayer"></a>2.主角AVPlayer</h3><ul><li>AVPlayer需要的属性，这是播放器基础</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayer</span> *player;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerItem</span> *playerItem;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerLayer</span> *playerLayer;<br><br></code></pre></td></tr></table></figure><ul><li>实现AVPlayer播放</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"> <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:_playerUrl];<br>_item = [[<span class="hljs-built_in">AVPlayerItem</span> alloc] initWithURL:url];<br>_player = [<span class="hljs-built_in">AVPlayer</span> playerWithPlayerItem:_item];<br>_playerLayer = [<span class="hljs-built_in">AVPlayerLayer</span> playerLayerWithPlayer:_player];<br>_playerLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>;<br>[<span class="hljs-keyword">self</span>.layer addSublayer:_playerLayer];<br>[_player play];<br></code></pre></td></tr></table></figure><p>虽然是可以播放视频了但仅仅是能播放而已，暂停播放快进等功能都没有，下面对他进行完善。</p><ul><li>添加底部工具栏</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIView</span> *toolView;<span class="hljs-comment">//工具栏</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UISlider</span> *slider;<span class="hljs-comment">//用来现实视频的播放进度</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-type">BOOL</span> isShowToolView;<span class="hljs-comment">//是否显示工具栏</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIButton</span> *playOrPause;<span class="hljs-comment">//播放暂停按钮</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSTimer</span> *showTimer;<span class="hljs-comment">//显示工具栏时间</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSTimer</span> *progressTimer;<span class="hljs-comment">//进度条计时器</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UILabel</span> *timerLabel;<span class="hljs-comment">//播放时间</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UILabel</span> *allTimeLabel;<span class="hljs-comment">//总时间</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIButton</span> *bigPlayBtn;<span class="hljs-comment">//中间播放按钮</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIView</span> *coverView;<span class="hljs-comment">//遮盖版</span><br><br></code></pre></td></tr></table></figure><ul><li>下面就是界面实现了</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//工具栏</span><br>       <span class="hljs-keyword">self</span>.toolView = [[<span class="hljs-built_in">UIView</span> alloc]initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.bounds.size.height - kToolViewHieght, <span class="hljs-keyword">self</span>.bounds.size.width, kToolViewHieght)];<br>       <span class="hljs-keyword">self</span>.toolView.backgroundColor = [<span class="hljs-built_in">UIColor</span> colorWithWhite:<span class="hljs-number">0</span> alpha:<span class="hljs-number">0.8</span>];<br>       [<span class="hljs-keyword">self</span> addSubview:<span class="hljs-keyword">self</span>.toolView];<br>       [<span class="hljs-keyword">self</span> bringSubviewToFront:<span class="hljs-keyword">self</span>.toolView];<br></code></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//播放按钮</span><br>      <span class="hljs-keyword">self</span>.playOrPause = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>      [<span class="hljs-keyword">self</span>.playOrPause setImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;videoplay&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>      [<span class="hljs-keyword">self</span>.playOrPause setImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;videopause&quot;</span>] forState:<span class="hljs-built_in">UIControlStateSelected</span>];<br>      <span class="hljs-keyword">self</span>.playOrPause.contentMode = <span class="hljs-built_in">UIViewContentModeCenter</span>;<br>      [<span class="hljs-keyword">self</span>.playOrPause addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(playOrPauseClick:) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br>      <span class="hljs-keyword">self</span>.playOrPause.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, kToolViewHieght);<br>      [<span class="hljs-keyword">self</span>.toolView addSubview:<span class="hljs-keyword">self</span>.playOrPause];<br><br></code></pre></td></tr></table></figure><ul><li>其他控件</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.timerLabel = [[<span class="hljs-built_in">UILabel</span> alloc]initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, kToolViewHieght)];<br><span class="hljs-keyword">self</span>.timerLabel.font = [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">10.0</span>];<br><span class="hljs-keyword">self</span>.timerLabel.textColor = [<span class="hljs-built_in">UIColor</span> whiteColor];<br>[<span class="hljs-keyword">self</span>.toolView addSubview:<span class="hljs-keyword">self</span>.timerLabel];<br><br><span class="hljs-keyword">self</span>.allTimeLabel  =[[<span class="hljs-built_in">UILabel</span> alloc]initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">70</span>, <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, kToolViewHieght)];<br><span class="hljs-keyword">self</span>.allTimeLabel.font = [<span class="hljs-built_in">UIFont</span> systemFontOfSize:<span class="hljs-number">10.0</span>];<br><span class="hljs-keyword">self</span>.allTimeLabel.textColor = [<span class="hljs-built_in">UIColor</span> whiteColor];<br>[<span class="hljs-keyword">self</span>.toolView addSubview:<span class="hljs-keyword">self</span>.allTimeLabel];<br><br><span class="hljs-keyword">self</span>.bigPlayBtn = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>[<span class="hljs-keyword">self</span>.bigPlayBtn setImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;videoplay&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>[<span class="hljs-keyword">self</span>.bigPlayBtn addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(playOrPauseBigClick:) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br><span class="hljs-keyword">self</span>.bigPlayBtn.frame = <span class="hljs-keyword">self</span>.bounds;<br><span class="hljs-keyword">self</span>.bigPlayBtn.contentMode = <span class="hljs-built_in">UIViewContentModeScaleAspectFill</span>;<br>[<span class="hljs-keyword">self</span> addSubview:<span class="hljs-keyword">self</span>.bigPlayBtn];<br><br><br><span class="hljs-keyword">self</span>.coverView.hidden = <span class="hljs-literal">YES</span>;<br><span class="hljs-keyword">self</span>.toolView.alpha = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">self</span>.isShowToolView = <span class="hljs-literal">NO</span>;<br><span class="hljs-keyword">self</span>.playOrPause.selected = <span class="hljs-literal">NO</span>;<br><br></code></pre></td></tr></table></figure><ul><li>进度条 </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//懒加载进度条</span><br>- (<span class="hljs-built_in">UISlider</span> *)slider&#123;<br>    <span class="hljs-keyword">if</span> (!_slider) &#123;<br>        _slider.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor];<br>        _slider = [[<span class="hljs-built_in">UISlider</span> alloc]initWithFrame:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">110</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, kToolViewHieght)];<br>        <span class="hljs-comment">//设置slider原点已经最大点最小点图片</span><br>        [_slider setThumbImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;videothumb&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>        [_slider addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(touchDown:) forControlEvents:<span class="hljs-built_in">UIControlEventTouchDown</span>];<br>        [_slider addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(valueChange:) forControlEvents:<span class="hljs-built_in">UIControlEventValueChanged</span>];<br>        [_slider addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(touchUpInside:) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> _slider;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>进度条点击方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)touchDown:(<span class="hljs-built_in">UISlider</span> *)slider&#123;<br>    <span class="hljs-comment">// 按下去 移除监听器</span><br>    [<span class="hljs-keyword">self</span> removeProgressTimer];<br>    [<span class="hljs-keyword">self</span> removeShowTime];<br>&#125;<br>- (<span class="hljs-type">void</span>)valueChange:(<span class="hljs-built_in">UISlider</span> *)slider&#123;<br>    <span class="hljs-built_in">NSTimeInterval</span> currentTime = <span class="hljs-built_in">CMTimeGetSeconds</span>(<span class="hljs-keyword">self</span>.player.currentItem.duration) * slider.value;<br>    <span class="hljs-keyword">self</span>.timerLabel.text = [<span class="hljs-keyword">self</span> timeToStringWithTimeInterval:currentTime];<br>&#125;<br>- (<span class="hljs-type">void</span>)touchUpInside:(<span class="hljs-built_in">UISlider</span> *)slider&#123;<br>    [<span class="hljs-keyword">self</span> addProgressTimer];<br>    <span class="hljs-comment">//计算当前slider拖动对应的播放时间</span><br>    <span class="hljs-built_in">NSTimeInterval</span> currentTime = <span class="hljs-built_in">CMTimeGetSeconds</span>(<span class="hljs-keyword">self</span>.player.currentItem.duration) * slider.value;<br>    <span class="hljs-comment">// seekToTime:播放跳转到当前播放时间</span><br>    [<span class="hljs-keyword">self</span>.player seekToTime:<span class="hljs-built_in">CMTimeMakeWithSeconds</span>(currentTime, <span class="hljs-built_in">NSEC_PER_SEC</span>) toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];<br>    [<span class="hljs-keyword">self</span> toolViewShow];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>slider定时器</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSTimer</span> *)progressTimer&#123;<br>    <span class="hljs-keyword">if</span> (!_progressTimer) &#123;<br>        _progressTimer = [<span class="hljs-built_in">NSTimer</span> timerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(updateProgressInfo) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>        [[<span class="hljs-built_in">NSRunLoop</span> mainRunLoop]addTimer:<span class="hljs-keyword">self</span>.progressTimer forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> _progressTimer;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li> 更新slider和time</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)updateProgressInfo&#123;<br>    <span class="hljs-built_in">NSTimeInterval</span> currentTime = <span class="hljs-built_in">CMTimeGetSeconds</span>(<span class="hljs-keyword">self</span>.player.currentTime);<br>    <span class="hljs-built_in">NSTimeInterval</span> durationTime = <span class="hljs-built_in">CMTimeGetSeconds</span>(<span class="hljs-keyword">self</span>.player.currentItem.duration);<br>    <br>    <span class="hljs-keyword">self</span>.timerLabel.text = [<span class="hljs-keyword">self</span> timeToStringWithTimeInterval:currentTime];<br>    <span class="hljs-keyword">self</span>.allTimeLabel.text = [<span class="hljs-keyword">self</span> timeToStringWithTimeInterval:durationTime];<br>    <span class="hljs-keyword">self</span>.slider.value = <span class="hljs-built_in">CMTimeGetSeconds</span>(<span class="hljs-keyword">self</span>.player.currentTime)/<span class="hljs-built_in">CMTimeGetSeconds</span>(<span class="hljs-keyword">self</span>.player.currentItem.duration);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.slider.value == <span class="hljs-number">1</span>) &#123;<br>        [<span class="hljs-keyword">self</span> removeProgressTimer];<br>        <span class="hljs-keyword">self</span>.coverView.hidden = <span class="hljs-literal">NO</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li> 移除slider定时器</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//移除slider定时器</span><br>- (<span class="hljs-type">void</span>)removeProgressTimer&#123;<br>    [<span class="hljs-keyword">self</span>.progressTimer invalidate];<br>    <span class="hljs-keyword">self</span>.progressTimer = <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>播放器的手势点击</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//手势点击</span><br>- (<span class="hljs-type">void</span>)playTap:(<span class="hljs-built_in">UITapGestureRecognizer</span> *)tap&#123;<br>    <span class="hljs-comment">//未播放状态，点击view会直接播放</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.player.status == <span class="hljs-built_in">AVPlayerStatusUnknown</span>) &#123;<br>        [<span class="hljs-keyword">self</span> playOrPauseClick:<span class="hljs-keyword">self</span>.playOrPause];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//记录工具栏的是否隐藏</span><br>    <span class="hljs-keyword">self</span>.isShowToolView = !<span class="hljs-keyword">self</span>.isShowToolView;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isShowToolView) &#123;<br>        [<span class="hljs-built_in">UIView</span> animateWithDuration:<span class="hljs-number">0.5</span> animations:^&#123;<br>            <span class="hljs-keyword">self</span>.toolView.alpha = <span class="hljs-number">0.8</span>;<br>        &#125;];<br>        <span class="hljs-comment">//工具栏的按钮为播放状态是，添加计时器，5秒之后自动隐藏</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.playOrPause.selected) &#123;<br>            [<span class="hljs-keyword">self</span> toolViewShow];<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        [<span class="hljs-keyword">self</span> removeShowTime];<br>        [<span class="hljs-built_in">UIView</span> animateWithDuration:<span class="hljs-number">0.5</span> animations:^&#123;<br>            <span class="hljs-keyword">self</span>.toolView.alpha = <span class="hljs-number">0</span>;<br>        &#125;];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>播放按钮方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)playOrPauseClick:(<span class="hljs-built_in">UIButton</span> *)btn&#123;<br>    btn.selected = !btn.selected;<br>    <span class="hljs-keyword">if</span> (!btn.selected) &#123;<br>        <span class="hljs-keyword">self</span>.toolView.alpha = <span class="hljs-number">0.8</span>;<br>        [<span class="hljs-keyword">self</span> removeShowTime];<br>        [<span class="hljs-keyword">self</span>.player pause];<br>        [<span class="hljs-keyword">self</span> removeProgressTimer];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        [<span class="hljs-keyword">self</span> toolViewShow];<br>        [<span class="hljs-keyword">self</span>.player play];<br>        [<span class="hljs-keyword">self</span> addProgressTimer];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>中间播放按钮的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//中间播放按钮的方法</span><br>- (<span class="hljs-type">void</span>)playOrPauseBigClick:(<span class="hljs-built_in">UIButton</span> *)btn&#123;<br>    btn.hidden = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">self</span>.playOrPause.selected = <span class="hljs-literal">YES</span>;<br>    [<span class="hljs-keyword">self</span>.player replaceCurrentItemWithPlayerItem:<span class="hljs-keyword">self</span>.playerItem];<br>    [<span class="hljs-keyword">self</span>.player play];<br>    [<span class="hljs-keyword">self</span> addProgressTimer];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>工具栏的显示及隐藏</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)toolViewShow&#123;<br>    <span class="hljs-keyword">self</span>.showTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">5.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(toolViewHide) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">NO</span>];<br>    [[<span class="hljs-built_in">NSRunLoop</span> mainRunLoop]addTimer:<span class="hljs-keyword">self</span>.showTimer forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<br>&#125;<br>- (<span class="hljs-type">void</span>)toolViewHide&#123;<br>    <span class="hljs-keyword">self</span>.isShowToolView = !<span class="hljs-keyword">self</span>.isShowToolView;<br>    [<span class="hljs-built_in">UIView</span> animateWithDuration:<span class="hljs-number">0.5</span> animations:^&#123;<br>        <span class="hljs-keyword">self</span>.toolView.alpha = <span class="hljs-number">0</span>;<br>    &#125;];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;工具栏隐藏&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>添加遮罩视图用于播放完成后</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">UIView</span> *)coverView&#123;<br>    <span class="hljs-keyword">if</span> (!_coverView) &#123;<br>        _coverView = [<span class="hljs-built_in">UIView</span> new];<br>        _coverView.center = <span class="hljs-keyword">self</span>.center;<br>        _coverView.bounds = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>        _coverView.backgroundColor = [<span class="hljs-built_in">UIColor</span> colorWithWhite:<span class="hljs-number">0</span> alpha:<span class="hljs-number">0.9</span>];<br>        [<span class="hljs-keyword">self</span> addSubview:_coverView];<br>    &#125;<br>    <span class="hljs-keyword">return</span> _coverView;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在遮罩视图上添加重播按钮</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIButton</span> *ReplayBtn = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>[ReplayBtn setImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;chongshe&quot;</span>] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>ReplayBtn.center = <span class="hljs-keyword">self</span>.coverView.center;<br>ReplayBtn.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>[ReplayBtn addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(rePlayClick) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br>[<span class="hljs-keyword">self</span>.coverView addSubview:ReplayBtn];<br><br></code></pre></td></tr></table></figure><ul><li>重播按钮的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)rePlayClick&#123;<br>    <span class="hljs-keyword">self</span>.slider.value = <span class="hljs-number">0</span>;<br>    [<span class="hljs-keyword">self</span> touchUpInside:<span class="hljs-keyword">self</span>.slider];<br>    <span class="hljs-keyword">self</span>.coverView.hidden = <span class="hljs-literal">YES</span>;<br>    [<span class="hljs-keyword">self</span> playOrPauseBigClick:<span class="hljs-keyword">self</span>.bigPlayBtn];<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>到这里一个带有播放暂停重播等基本功能的播发器就完成了</li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/strip-20230415203643675.gif" alt="完成效果图"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li> 上面是我用AVPlayer实现播放的一点心得。demo做的很简陋，有诸多的不足，需要完善的地方也有很多，主要是为了给大家提供一个思路抛砖引玉，希望可以帮到大家。</li><li>惯例放上<a href="https://github.com/Hey2Li/AVPlayerDemo">项目源码</a>还有我的<a href="https://www.jianshu.com/p/588b315774b1">简书</a>，有需要的可以去看一下。</li><li>参考文章<a href="http://www.jianshu.com/p/b3631d22f721">iOS-视频播放器的简单封装</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS开发实现TouchID指纹解锁</title>
    <link href="/2016/08/30/iOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0TouchID%E6%8C%87%E7%BA%B9%E8%A7%A3%E9%94%81/"/>
    <url>/2016/08/30/iOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0TouchID%E6%8C%87%E7%BA%B9%E8%A7%A3%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一直想实现一下指纹解锁，苦于一直没时间，最近终于闲了下来所以翻了翻文档看了看demo，完成了这篇教程。本功能实现起来是很简单的，因为苹果都已经帮我们封装好了，只需要实现几个方法就可以了。</p></blockquote><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/1240-20230415202922677" alt="实现效果图"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-首先引入指纹解锁必须的头文件"><a href="#1-首先引入指纹解锁必须的头文件" class="headerlink" title="1.首先引入指纹解锁必须的头文件"></a>1.首先引入指纹解锁必须的头文件</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#import <span class="hljs-string">&lt;LocalAuthentication/LocalAuthentication.h&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-了解下主要的两个方法"><a href="#2-了解下主要的两个方法" class="headerlink" title="2.了解下主要的两个方法"></a>2.了解下主要的两个方法</h3><p>这个方法是判断设备是否支持TouchID的。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>canEvaluatePolicy:<span class="hljs-params">(LAPolicy)</span>policy error:<span class="hljs-params">(NSError * __autoreleasing *)</span>error __attribute__<span class="hljs-params">((swift_error(none))</span>);<br></code></pre></td></tr></table></figure><p>这个是用来验证TouchID的，会有弹出框出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)evaluatePolicy:(LAPolicy)policy<br>       localizedReason:(<span class="hljs-built_in">NSString</span> *)localizedReason<br>                 reply:(<span class="hljs-type">void</span>(^)(<span class="hljs-type">BOOL</span> success, <span class="hljs-built_in">NSError</span> * __<span class="hljs-keyword">nullable</span> error))reply;<br></code></pre></td></tr></table></figure><h3 id="3-新建LAContext对象"><a href="#3-新建LAContext对象" class="headerlink" title="3.新建LAContext对象"></a>3.新建<code>LAContext</code>对象</h3><h4 id="主要的属性设置"><a href="#主要的属性设置" class="headerlink" title="主要的属性设置"></a>主要的属性设置</h4><ul><li><p><code> localizedFallbackTitle</code>：用于设置左边的按钮的名称，默认是<code>Enter Password</code>.</p></li><li><p> <code>localizedReason</code>：用于设置提示语，表示为什么要使用<code>Touch ID</code><br><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/1240-20230415202938893" alt="解锁失败界面"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//创建LAContext</span><br>LAContext *<span class="hljs-keyword">context</span> = [LAContext <span class="hljs-keyword">new</span>];<br><br><span class="hljs-comment">//这个属性是设置指纹输入失败之后的弹出框的选项</span><br><span class="hljs-keyword">context</span><span class="hljs-variable">.localizedFallbackTitle</span> = @<span class="hljs-string">&quot;没有忘记密码&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-主要回调方法，包括成功以及失败的"><a href="#4-主要回调方法，包括成功以及失败的" class="headerlink" title="4.主要回调方法，包括成功以及失败的"></a>4.主要回调方法，包括成功以及失败的</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;支持指纹识别&quot;</span>);<br>        [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:<span class="hljs-string">@&quot;指纹解锁&quot;</span> reply:^(<span class="hljs-type">BOOL</span> success, <span class="hljs-built_in">NSError</span> * _Nullable error) &#123;<br>            <span class="hljs-keyword">if</span> (success) &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;验证成功 刷新主界面&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,error.localizedDescription);<br>                <span class="hljs-keyword">switch</span> (error.code) &#123;<br>                    <span class="hljs-keyword">case</span> LAErrorSystemCancel:<br>                    &#123;<br>                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;系统取消授权，如其他APP切入&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> LAErrorUserCancel:<br>                    &#123;<br>                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;用户取消验证Touch ID&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> LAErrorAuthenticationFailed:<br>                    &#123;<br>                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;授权失败&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> LAErrorPasscodeNotSet:<br>                    &#123;<br>                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;系统未设置密码&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> LAErrorTouchIDNotAvailable:<br>                    &#123;<br>                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;设备Touch ID不可用，例如未打开&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> LAErrorTouchIDNotEnrolled:<br>                    &#123;<br>                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;设备Touch ID不可用，用户未录入&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> LAErrorUserFallback:<br>                    &#123;<br>                        [[<span class="hljs-built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;<br>                            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;用户选择输入密码，切换主线程处理&quot;</span>);<br>                        &#125;];<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">default</span>:<br>                    &#123;<br>                        [[<span class="hljs-built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;<br>                            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;其他情况，切换主线程处理&quot;</span>);<br>                        &#125;];<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;不支持指纹识别&quot;</span>);<br>        <span class="hljs-keyword">switch</span> (error.code) &#123;<br>            <span class="hljs-keyword">case</span> LAErrorTouchIDNotEnrolled:<br>            &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;TouchID is not enrolled&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> LAErrorPasscodeNotSet:<br>            &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A passcode has not been set&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>            &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;TouchID not available&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,error.localizedDescription);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>做到这里几乎就算完成，使用确实很简单，因为苹果都已经给我们做好一切，对我们开发者来说就很轻松了。教程写的很简陋，希望大家多多包涵，代码我已经传到<a href="https://github.com/Hey2Li/TouchID.git">GitHub</a>了，还有我的<a href="https://www.jianshu.com/p/b522f0ddea78">简书</a>。<br>最后希望可以帮到大家。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jianshu.com/p/8ba83ec5688a/comments/2564595">iOS指纹解锁</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS启动图实现视频动画</title>
    <link href="/2016/08/12/iOS%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%8A%A8%E7%94%BB/"/>
    <url>/2016/08/12/iOS%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>因为产品需求以及后台都未完成，所以最近在公司也没什么工作要做，主要也就看看技术文章，写写东西。今天的这个东西是一个关于启动页或者引导页的视频动画效果的实现过程，原型也是我们产品给我看的一个APP。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>废话不多说，先上效果图</li></ul><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/strip-20230415203304936.gif" alt="完成效果图.gif"></p><ul><li>接下来说下思路了</li></ul><p>说实话刚开始我有点彷徨的，因为我以前并没有做过，接下来我把那个APP的里的资源给拿到了，发现一个.mp4的视频，我就记起我以前看过的一篇文章<a href="http://www.jianshu.com/p/2b03d19f4acd">iOS&lt;咸鱼APP&gt;新特性界面-视频动画</a>，真是惭愧，借鉴了一下，然后就有了我的这篇文章。</p><p>主要思路就是用一个控制器来作为播放视频的载体，然后在让这个控制器作为根视图，视频播放完成之后那就该干嘛干嘛了。<br>感觉废话说的有点多啊，下面就放代码好了</p><p>先新建一个控制器<code>AnimationViewController</code>在控制器中新建一个属性<code>moviePlayer </code>，记得要先引入系统库<code>&lt;MediaPlayer/MediaPlayer.h&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, strong) MPMoviePlayerController *moviePlayer;<br></code></pre></td></tr></table></figure><p>设置<code>moviePlayer</code>我是在懒加载中直接设置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(MPMoviePlayerController *)moviePlayer&#123;<br>    if (!_moviePlayer) &#123;<br>        _moviePlayer = [[MPMoviePlayerController alloc]init];<br>        [_moviePlayer.view setFrame:self.view.bounds];<br>        //设置自动播放<br>        [_moviePlayer setShouldAutoplay:NO];<br>        //设置源类型 因为新特性一般都是播放本地的小视频 所以设置源类型为file<br>        _moviePlayer.movieSourceType = MPMovieSourceTypeFile;<br>        //取消控制视图 如：播放暂停等<br>        _moviePlayer.controlStyle = MPMovieControlStyleNone;<br>        [self.view addSubview:_moviePlayer.view];<br>        //监听播放完成<br>        [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(playFinsihed) name:MPMoviePlayerPlaybackDidFinishNotification object:nil];<br>    &#125;<br>    return _moviePlayer;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>.h</code>中公开一个<code>moviePath</code>视频的路径，还有一个结束播放的block<code>playFinished</code>等下需要。</p><p><code>AnimationViewController</code>中也算差不多了，毕竟也没什么东西，接下来我们去<code>AppDelegate</code>中声明一个<code>AnimationViewController</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (AnimationViewController *)animationViewController&#123;<br>    if (!_animationViewController) &#123;<br>        _animationViewController = [[AnimationViewController alloc]init];<br>       //设置本地视频路径<br>        _animationViewController.moviePath = [[NSBundle mainBundle] pathForResource:@&quot;V&quot; ofType:@&quot;mp4&quot;];<br>        _animationViewController.playFinished = ^&#123;<br>            UINavigationController *rootNav = [[UINavigationController alloc] initWithRootViewController:[[ViewController alloc] init]];<br>            [UIApplication sharedApplication].keyWindow.rootViewController = rootNav;<br>        &#125;;<br>    &#125;<br>    return _animationViewController;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>AppDelegate</code>的启动方法把这个控制器设为根视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;<br>    self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];<br>    self.window.rootViewController = self.animationViewController;<br>    [self.window makeKeyAndVisible];<br>    return YES;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>基本算是完成了,惯例放上我的<a href="https://github.com/Hey2Li/LaunchAnimationDemo">源码</a>还有我的<a href="https://www.jianshu.com/p/57128437cb13">简书</a>，有需要的可以去看一下，最后希望可以帮到大家。</p><p><em>这里要说一句，刚开始我用这个路径但是一直为空，后来我添加了一个名字为<code>Resource</code>的文件夹把mp4放进去就好了，也不知道为什么。有知道也可以告诉我</em></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上滑隐藏NvaigtionBar，下拉显示</title>
    <link href="/2016/08/11/%E4%B8%8A%E6%BB%91%E9%9A%90%E8%97%8FNvaigtionBar%EF%BC%8C%E4%B8%8B%E6%8B%89%E6%98%BE%E7%A4%BA/"/>
    <url>/2016/08/11/%E4%B8%8A%E6%BB%91%E9%9A%90%E8%97%8FNvaigtionBar%EF%BC%8C%E4%B8%8B%E6%8B%89%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天和产品沟通，要仿照一个APP，发现这个APP上滑时隐藏navigationBar,虽然也是隐藏但是效果和其他完全不一样，因为以前没见过也没做过，所以试着去实现一下，Google了一下，发现思路主要还是从KVO来下手。</p></blockquote><h2 id="原APP的效果"><a href="#原APP的效果" class="headerlink" title="原APP的效果"></a>原APP的效果</h2><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/strip" alt="2016-08-11 16_23_42.gif"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ul><li><p>主要是给view中的滚动视图添加一个KVO来监视它的滑动，再根据它的offset来做一下操作，下面是代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[myTableView addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;contentOffset&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionOld</span>|<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> context:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure></li><li><p> 获取tableView的<code>contentOffset</code>之后再根据具体需求来实现逻辑判断</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([object isEqual:myTableView] &amp;&amp; [keyPath isEqualToString:<span class="hljs-string">@&quot;contentOffset&quot;</span>]) &#123;<br>        <span class="hljs-comment">//获取新值旧值</span><br>        <span class="hljs-built_in">CGFloat</span> newY = [change[<span class="hljs-string">@&quot;new&quot;</span>] <span class="hljs-built_in">CGPointValue</span>].y;<br>        <span class="hljs-built_in">CGFloat</span> oldY = [change[<span class="hljs-string">@&quot;old&quot;</span>] <span class="hljs-built_in">CGPointValue</span>].y;<br>        <span class="hljs-type">float</span> i = newY - oldY;<span class="hljs-comment">//下拉是新值小于旧值的，所以i&lt;0 是下拉 i&gt;0 是上滑</span><br>         <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%f&quot;</span>,myTableView.contentOffset.y);<br>        <span class="hljs-keyword">if</span> (myTableView.contentOffset.y &gt; <span class="hljs-number">-64</span> &amp;&amp; myTableView.contentOffset.y &lt;= <span class="hljs-number">24</span>) &#123;<span class="hljs-comment">//边界条件，此处不精确</span><br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0</span> &amp;&amp; _isHide == <span class="hljs-literal">NO</span> &amp;&amp; <span class="hljs-keyword">self</span>.navigationController.navigationBar.frame.origin.y == <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-comment">//下拉＋bar 已经显示的状态，不再移动</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            _isHide = <span class="hljs-literal">NO</span>;<br>            <span class="hljs-comment">//设置navigationbar 的frame 使他根据tableView来滑动</span><br>            <span class="hljs-keyword">self</span>.navigationController.navigationBar.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-44</span> - myTableView.contentOffset.y, <span class="hljs-keyword">self</span>.view.bounds.size.width, <span class="hljs-number">44</span>);<br>            <span class="hljs-comment">//控制透明度</span><br>            <span class="hljs-keyword">self</span>.navigationController.navigationBar.alpha = -myTableView.contentOffset.y/<span class="hljs-number">64</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (myTableView.contentOffset.y &gt; <span class="hljs-number">24</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">10</span>) &#123;<span class="hljs-comment">//更改数值大小可以控制触发 navigation bar 的滑动速度</span><br>                _isHide = <span class="hljs-literal">YES</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">-10</span>) &#123;<br>                _isHide = <span class="hljs-literal">NO</span>;<br>            &#125;<br>        &#125;<br>        [<span class="hljs-keyword">self</span>.navigationController setNavigationBarHidden:_isHide animated:<span class="hljs-literal">YES</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完成效果图"><a href="#完成效果图" class="headerlink" title="完成效果图"></a>完成效果图</h2><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/strip.gif" alt="2016-08-11 15_55_00.gif"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>实现起来确实没有什么难度，主要是因为以前没有做过，写这个主要是给大家看一下我的实现过程与思路，希望可以帮到大家。</p></li><li><p>我把源码上传到<a href="https://github.com/Hey2Li/HideNavi.git">GitHub</a>了，需要的可以看一下。</p></li><li><p>我的<a href="https://www.jianshu.com/p/6fbbe24bde67">简书</a>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下使用Hexo和GitHub搭建静态博客</title>
    <link href="/2016/07/13/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2016/07/13/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="更新-此为迁移文章"><a href="#更新-此为迁移文章" class="headerlink" title="更新: 此为迁移文章"></a>更新: 此为迁移文章</h1><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote><p>最近看网上有用Hexo和GitHub的搭建博客的教程，自己也学着搭建了一个，过程分享一下</p></blockquote><h1 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h1><p>因为博客是托管于<a href="www.github.com">GitHub</a>上，所以一个GitHub账户是必须的，注册的步骤就不介绍了，注册完以后选择免费服务即可。拥有一个GitHub账号以后，我们要新建一个仓库，点击首页右下角的<code>+ New repository</code>，就会出现如下界面：</p><p><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/1240" alt="QQ20160713-0@2x.png"></p><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>创建完仓库后，我们在电脑上安装Git，这样可以在本地建立项目并push到远程仓库上。</p><p>推荐使用Homebrew来安装Git。打开终端（Windows用户可以使用Git Bash等），输入以下指令安装Homebrew（Mac需要安装Xcode）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br><span class="hljs-variable">$</span>  ruby <span class="hljs-literal">-e</span> <span class="hljs-string">&quot;<span class="hljs-variable">$</span>(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><br></code></pre></td></tr></table></figure><p>这样我们就安装好了Git。如果出现问题，尝试在指令前加入sudo，sudo可以获得root权限，执行带有sudo的指令电脑会要求你输入密码。</p><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>接下来就是安装Node.js了，我对Node.js了解不多，Hexo是基于Node.js的，所以Node.js的环境是不可或缺的。<br>直接去<a href="https://nodejs.org/en/">Node.js官网</a>下载安装就可以了。<br>有了Git和Node.js，Hexo就可以安装了，但是先别急，我们还有一些事情要干。</p><p>#配置SSH keys<br>打开GitHub，在头像旁边有个向下的箭头，点击选择选中setting，点击左边的SSH and GPG keys，添加一个SSH keys。SSH keys的好处是让我们以后在本地进行操作并同步到GitHub上时不用输密码，那么如何配置SSH keys<br>打开终端，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> \\~/. ssh</span><br></code></pre></td></tr></table></figure><p>这行代码能够帮助你检查电脑上现有的SSH key。<br>如果提示：<code>No such file or directory</code>说明没有key文件，输入以下代码生成新的key文件：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮件地址@youremail.com&quot;</span><br></code></pre></td></tr></table></figure><p>这里的邮件地址填自己注册时的邮件地址，注意大小写，双引号不能省略，终端会返回代码让你确定文件名，回车就好。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.<br>Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>DoubleD<span class="hljs-regexp">/.ssh/i</span>d\\_rsa): <span class="hljs-comment">//回车就行</span><br></code></pre></td></tr></table></figure><p>接着会让你输入加密串，可以空着：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">$ Enter passphrase (empty for no passphrase):<span class="hljs-symbol">\\</span>&lt;输入加密串<span class="hljs-symbol">\\</span>&gt;<br>$ Enter same passphrase again:<span class="hljs-symbol">\\</span>&lt;再次输入加密串<span class="hljs-symbol">\\</span>&gt;<br></code></pre></td></tr></table></figure><p>看到如下所示的输出，就代表你已经成功的创建了一个SSH key。<br><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/1240-20230414164727388" alt="输出图"><br>找到本机上的id_rsa.pub文件,在终端输入：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">cd</span> <span class="hljs-string">.ssh</span><br>$ <span class="hljs-string">.ssh</span> open<br></code></pre></td></tr></table></figure><p>打开它（建议使用Sublime Text）复制里面的代码，记得不要多复制空格或换行，添加到下图位置：<br><img src="https://raw.githubusercontent.com/Hey2Li/blog.img/master/1240-20230414164807397" alt="QQ20160713-1@2x.png"><br>然后点击Add key就配置好了SSH key。输入下面的指令测试是否配置成功：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>如果返回的结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">he</span> authenticity of host &#x27;github.com (<span class="hljs-number">207.97.227.239</span>)&#x27; can&#x27;t be established.<br><span class="hljs-attribute">RSA</span> key fingerprint is <span class="hljs-number">16</span>:<span class="hljs-number">27</span>:ac:a5:<span class="hljs-number">76</span>:<span class="hljs-number">28</span>:<span class="hljs-number">2</span>d:<span class="hljs-number">36</span>:<span class="hljs-number">63</span>:<span class="hljs-number">1</span>b:<span class="hljs-number">56</span>:<span class="hljs-number">4</span>d:eb:df:a6:<span class="hljs-number">48</span>.<br><span class="hljs-attribute">Are</span> you sure you want to continue connecting (yes/no)?<br></code></pre></td></tr></table></figure><p>输入yes，就能看到</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi YourID! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>这样你的SSH key就配置完成了。完成之后，我们设置好个人信息，用于提交代码说明是谁提交的，怎么联系。可以用以下指令完成：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;你的名字&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span>  <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>打开终端，输入以下指令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>在电脑上你愿意的一个位置建立一个文件夹，名字任意，然后在该目录下执行以下指令（在终端中输入cd+空格+文件路径就可在该目录下执行指令）：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo init<br><span class="hljs-variable">$ </span>npm install<br></code></pre></td></tr></table></figure><p>Hexo就会在该文件夹建立博客所需要的所有文件。本地的Hexo博客已经初步搭建起来，输入以下指令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><span class="hljs-comment">//可以简写为 hexo g</span><br>$ hexo server<span class="hljs-comment">//可以简写为 hexo s</span><br></code></pre></td></tr></table></figure><p>就可以在浏览器中输入<a href="http://localhost:4000/">localhost:4000</a>查看本地博客了。要注意的是，所有的hexo指令都必须在你所建立的目录下执行。<br>#部署Hexo到GitHub上<br>本地的博客已经搭建好了，如何能让别人从网上访问到你的博客？只要将你的本地博客deploy到GitHub上就好。输入以下指令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后打开博客目录的_config.yml文件，设置deploy的type为git，repository(repo)<br>为 <code>https://github.com/你的id/你的id.github.io.git</code> （<strong>需要在type和repo后面加上一个空格再填写，一定要注意加空格，我就是在这里没加空格导致后面命令一直失败</strong>）。最后在你的Hexo目录中找到source文件夹，在其中新建一个文件CNAME，没有后缀名（建议使用Sublime Text新建），内容为你的域名（即ＸXXXXX．XXXXXX，不要加ＷＷＷ之类的前缀），保存。输入以下指令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> hexo g<br><span class="hljs-symbol">$</span> hexo deploy<span class="hljs-comment">//可简写为 hexo d</span><br></code></pre></td></tr></table></figure><p>在浏览器中输入你自己的域名就可以访问你自己的博客啦！</p><h1 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h1><p>这里是我使用的一个主题，包括使用方法上面已经介绍的很详细了 <a href="http://theme-next.iissnan.com/getting-started.html">NexT</a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>建好的博客是可以绑定其他域名的，我这里并没有的做，有兴趣的朋友可以看我下面的参考文章上面有如何申请域名以及绑定域名。</p><p>最后附上我刚刚才搭好的博客，很简陋上面都没有，让大家见笑了 <a href="https://hey2li.github.io/">旧</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>【1】<a href="https://hexo.io/zh-cn/docs/writing.html">hexo文档</a><br>【2】<a href="https://jmingzi.github.io/2015/12/04/github-hexo%E5%86%99%E6%96%87%E7%AB%A0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%AD%89%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/">github+hexo写文章上传图片等常用操作记录</a><br>【3】<a href="https://hexo.io/themes/">hexo主题</a><br>【4】<a href="https://xuanwo.org/2015/03/26/hexo-intor/">史上最详细的Hexo博客搭建图文教程</a><br>【5】<a href="http://www.jianshu.com/p/23760f7970f7">使用Hexo搭建自己的博客</a><br>【6】<a href="http://www.cnblogs.com/zhcncn/p/4097881.html">Hexo搭建Github静态博客</a><br>【7】<a href="http://yebujimo.com/2015/03/15/Mac%E4%B8%8B%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">Mac下搭建Hexo博客教程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1970/01/01/hello-world/"/>
    <url>/1970/01/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
